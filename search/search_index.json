{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FlubuCore \u00b6 Introduction \u00b6 \"FlubuCore - Fluent Builder Core\" is a cross platform build and deployment automation system. You can define your build and deployment scripts in C# using an intuitive fluent interface. This gives you code completion, IntelliSense, debugging, FlubuCore custom analyzers, and native access to the whole .NET ecosystem inside of your scripts. FlubuCore offers a .net (core) console application that uses power of roslyn to compile and execute scripts. Above example can be run from console with: FlubuCore runner flubu.exe Default FlubuCore dotnet cli tool dotnet flubu Default FlubuCore local or global tool flubu Default Features and Advantages \u00b6 Intuitive an easy to learn. C#, fluent interface, and IntelliSense make even most complex script creation a breeze. [FromArg(\"nugetKey\", \"Nuget api key for publishing Flubu nuget packages.\")] public string NugetApiKey { get ; set ; } protected override void ConfigureTargets ( ITaskContext context ) { var pack = context . CreateTarget ( \"Pack\" ) . SetDescription ( \"Prepare's nuget package.\" ) . AddCoreTask ( x => x . Pack () . NoBuild () . OutputDirectory ( OutputDirectory ) . WithArguments ( \"--force\" ); //you can add your own custom arguments on each task var branch = context . BuildSystems (). Travis (). Branch ; //// Examine travis.yaml to see how to pass api key from travis to FlubuCore build script. var nugetPush = context . CreateTarget ( \"Nuget.publish\" ) . SetDescription ( \"Publishes nuget package.\" ) . DependsOn ( pack ) . AddCoreTask ( x => x . NugetPush ( $ \"{OutputDirectory}/NetCoreOpenSource.nupkg\" ) . ServerUrl ( \"https://www.nuget.org/api/v2/package\" ) . ApiKey ( NugetApiKey ) ) . When (( c ) => c . BuildSystems (). RunningOn == BuildSystemType . TravisCI && ! string . IsNullOrEmpty ( branch ) && branch . EndsWith ( \"stable\" , StringComparison . OrdinalIgnoreCase )); } Large number of often used built-in tasks like e.g. versioning, running tests, creating deployment packages, publishing NuGet packages, docker tasks, git tasts, sql tasks, npm tasks, executing PowerShell, managing IIS scripts and many more. context . CreateTarget ( \"build\" ) . AddTask ( x => x . GitVersionTask ()) . AddTask ( x => x . CompileSolutionTask ( \"MySolution.sln\" ). BuildConfiguration ( \"Release\" ); context . CreateTarget ( \"run.tests\" ) . AddTask ( x => x . XunitTaskByProjectName ( \"MyProject\" ). StopOnFail ()) . AddTask ( x => x . NUnitTask ( NunitCmdOptions . V3 , \"MyProject2\" ). ExcludeCategory ( \"Linux\" )) . AddCoreTask ( x => x . CoverletTask ( \"MyProject.dll\" )); Execute your own custom C# code. context . CreateTarget ( \"DoExample\" ) . Do (( c ) => { //// write your awesome code. File . Copy ( \"NotSoAwesome.txt\" , Path . Combine ( OutputDirectory , \"JustAnExample.txt\" ) ); //// Access flubu built in tasks in DO if needed. c . Tasks (). GenerateT4Template ( \"example.TT\" ). Execute ( c ); }) . AddTask ( x => x . CompileSolutionTask ()) . Do ( NuGetPackageReferencingExample ); assembly references and nuget packages are loaded automatically when script is used together with project file. When script is executed alone (for example when deploying with FlubuCore script on production environment) references can be added with attributes. [NugetPackage(\"Newtonsoft.json\", \"11.0.2\")] [Assembly(\".\\Lib\\EntityFramework.dll\")] public class BuildScript : DefaultBuildScript { public void NuGetPackageReferencingExample ( ITaskContext context ) { JsonConvert . SerializeObject ( \"Example\" ); } } Easily run any external program or console command in your script. public class SimpleScript : DefaultBuildScript { protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Run.Libz\" ) . AddTask ( x => x . RunProgramTask ( @\"packages\\LibZ.Tool\\1.2.0\\tools\\libz.exe\" ) . WorkingFolder ( @\".\\src\" ) . WithArguments ( \"add\" ) . WithArguments ( \"--libz\" , \"Assemblies.libz\" )); } } Pass command line arguments, settings from json configuration file or environment variables to your script. public class SimpleScript : DefaultBuildScript { [FromArg(\"c\", \"The configuration to use for building the project.\")] public string Configuration { get ; set ; } = \"Release\" [FromArg(\"sn\", \"If true app is deployed on second node. Otherwise not.\")] public bool deployOnSecondNode { get ; set ; } protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"build\" ) . AddCoreTask ( x => x . Build () . Configuration ( Configuration ) . ForMember ( x => x . Framework ( \"net462\" ), \"f\" , \"The target framework to build for.\" )); } } flubu build -c=Debug -f=netcoreapp2.0 Extending FlubuCore fluent interface by writing your own tasks within FlubuCore plugins. public class ExampleFlubuPluginTask : TaskBase < int , ExampleFlubuPluginTask > { protected override int DoExecute ( ITaskContextInternal context ) { // Write your task logic here. return 0 ; } } Growing list of FlubuCore plugins complements built in tasks. Asynchronous execution of tasks, target dependencies and custom code. context . CreateTarget ( \"Run.Tests\" ) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName3\" )); Override existing options or add additional options to tasks through console c# context.CreateTarget(\"Example\")` .AddCoreTask(x => x.Build(\"MySolution.sln\").Configuration(\"Release\"); flubu example --configuration=Debug flubu would execute dotnet build MySolution.sln --configuration Debug Full .NET Core support including the global CLI tool dotnet tool install --global FlubuCore.GlobalTool flubu compile Possibility to test and debug your build scripts. context . WaitForDebugger (); Easily automate deployments remotely via the FlubuCore Web API. Possibility to use FlubuCore tasks in any other .NET application. FlubuCore interactive mode which offers target tab completition, options tab completition, toogle targets/options, executed commands history. It is also possible to execute external commands and operable programs. For some of them FlubuCore offers tab completion with help displayed at the bottom of console out of the box(such as dotnet, git..) Improved developer experience with FlubuCore custom analyzers. Getting Started \u00b6 Using FlubuCore is straightforward and very simple :-) It is also fully and throughly documented. The Getting Started chapter in Documentation will help you set up your first FlubuCore build in no time. You should also check getting started blog. It has some more details with some nice tips and tricks. A comprehensive list of features that FlubuCore has to offer with descriptions can be found in the Build Script Fundamentals chapter. Once you have your build and deployment scripts defined, the following Wiki chapters will explain how to run them: For .NET Framework projects use FlubuCore.Runner For .NET Core projects use FlubuCore CLI global tool Examples \u00b6 Aside from the detailed Wiki FlubuCore comes with example projects that reflect real-life situations. The examples can be found in the separate Examples repository . These examples will help you to get quickly start with FlubuCore: * .NET Framework build example - Example covers versioning, building the project, running tests, packaging application for deployment. .NET Core build example - Example covers versioning, building the project, running tests, packaging application for deployment. Deployment script example - Example shows how to write simple deployment script. Open source library example - Example covers versioning, building the project, running tests and publishing nuget package. It also covers how to run build script on Appveyor and Travis CI. Have a question? \u00b6 Contributing \u00b6 Please see CONTRIBUTING.md . Ways to Contribute \u00b6 Spread the word about the project. If you like the project don't forget to give it a star so that the community get's bigger. Improve documentation. Report, fix a bug. Implement a new feature. Discuss potential ways to improve project. Improve existing implementation, performance, etc. Further Development \u00b6 If you find FlubuCore useful (you feel it helps you on the daily basis) you can support further development by buying us a coffee (or become a backer or sponsor). Sometimes it's hard to stay awake till midnight implementing new features, coffee helps us with that. We would really appreciate your support. Money from sponsorship will also be used for the promotion of the project. If you are a backer or a sponsor you can also request for a new feature or ask for support. These issues will be handled with highest priority. Backers and Sponsors \u00b6 Changelog and Roadmap \u00b6 Changes with description and examples can be found in Changelog. You can see FlubuCore roadmap by exploring opened Milestones. Acknowledgements \u00b6 Special thanks to @ironcev for greatly improving readme and for giving some valuable advices. Special thanks to @alexinea for translating whole documentation to Chinese. Special thanks to @huanlin for writing blogs about FlubuCore in Traditional Chinese and for translating them to English. .NET Foundation \u00b6 This project is supported by the .NET Foundation .","title":"FlubuCore"},{"location":"#flubucore","text":"","title":"FlubuCore"},{"location":"#introduction","text":"\"FlubuCore - Fluent Builder Core\" is a cross platform build and deployment automation system. You can define your build and deployment scripts in C# using an intuitive fluent interface. This gives you code completion, IntelliSense, debugging, FlubuCore custom analyzers, and native access to the whole .NET ecosystem inside of your scripts. FlubuCore offers a .net (core) console application that uses power of roslyn to compile and execute scripts. Above example can be run from console with: FlubuCore runner flubu.exe Default FlubuCore dotnet cli tool dotnet flubu Default FlubuCore local or global tool flubu Default","title":"Introduction"},{"location":"#features-and-advantages","text":"Intuitive an easy to learn. C#, fluent interface, and IntelliSense make even most complex script creation a breeze. [FromArg(\"nugetKey\", \"Nuget api key for publishing Flubu nuget packages.\")] public string NugetApiKey { get ; set ; } protected override void ConfigureTargets ( ITaskContext context ) { var pack = context . CreateTarget ( \"Pack\" ) . SetDescription ( \"Prepare's nuget package.\" ) . AddCoreTask ( x => x . Pack () . NoBuild () . OutputDirectory ( OutputDirectory ) . WithArguments ( \"--force\" ); //you can add your own custom arguments on each task var branch = context . BuildSystems (). Travis (). Branch ; //// Examine travis.yaml to see how to pass api key from travis to FlubuCore build script. var nugetPush = context . CreateTarget ( \"Nuget.publish\" ) . SetDescription ( \"Publishes nuget package.\" ) . DependsOn ( pack ) . AddCoreTask ( x => x . NugetPush ( $ \"{OutputDirectory}/NetCoreOpenSource.nupkg\" ) . ServerUrl ( \"https://www.nuget.org/api/v2/package\" ) . ApiKey ( NugetApiKey ) ) . When (( c ) => c . BuildSystems (). RunningOn == BuildSystemType . TravisCI && ! string . IsNullOrEmpty ( branch ) && branch . EndsWith ( \"stable\" , StringComparison . OrdinalIgnoreCase )); } Large number of often used built-in tasks like e.g. versioning, running tests, creating deployment packages, publishing NuGet packages, docker tasks, git tasts, sql tasks, npm tasks, executing PowerShell, managing IIS scripts and many more. context . CreateTarget ( \"build\" ) . AddTask ( x => x . GitVersionTask ()) . AddTask ( x => x . CompileSolutionTask ( \"MySolution.sln\" ). BuildConfiguration ( \"Release\" ); context . CreateTarget ( \"run.tests\" ) . AddTask ( x => x . XunitTaskByProjectName ( \"MyProject\" ). StopOnFail ()) . AddTask ( x => x . NUnitTask ( NunitCmdOptions . V3 , \"MyProject2\" ). ExcludeCategory ( \"Linux\" )) . AddCoreTask ( x => x . CoverletTask ( \"MyProject.dll\" )); Execute your own custom C# code. context . CreateTarget ( \"DoExample\" ) . Do (( c ) => { //// write your awesome code. File . Copy ( \"NotSoAwesome.txt\" , Path . Combine ( OutputDirectory , \"JustAnExample.txt\" ) ); //// Access flubu built in tasks in DO if needed. c . Tasks (). GenerateT4Template ( \"example.TT\" ). Execute ( c ); }) . AddTask ( x => x . CompileSolutionTask ()) . Do ( NuGetPackageReferencingExample ); assembly references and nuget packages are loaded automatically when script is used together with project file. When script is executed alone (for example when deploying with FlubuCore script on production environment) references can be added with attributes. [NugetPackage(\"Newtonsoft.json\", \"11.0.2\")] [Assembly(\".\\Lib\\EntityFramework.dll\")] public class BuildScript : DefaultBuildScript { public void NuGetPackageReferencingExample ( ITaskContext context ) { JsonConvert . SerializeObject ( \"Example\" ); } } Easily run any external program or console command in your script. public class SimpleScript : DefaultBuildScript { protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Run.Libz\" ) . AddTask ( x => x . RunProgramTask ( @\"packages\\LibZ.Tool\\1.2.0\\tools\\libz.exe\" ) . WorkingFolder ( @\".\\src\" ) . WithArguments ( \"add\" ) . WithArguments ( \"--libz\" , \"Assemblies.libz\" )); } } Pass command line arguments, settings from json configuration file or environment variables to your script. public class SimpleScript : DefaultBuildScript { [FromArg(\"c\", \"The configuration to use for building the project.\")] public string Configuration { get ; set ; } = \"Release\" [FromArg(\"sn\", \"If true app is deployed on second node. Otherwise not.\")] public bool deployOnSecondNode { get ; set ; } protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"build\" ) . AddCoreTask ( x => x . Build () . Configuration ( Configuration ) . ForMember ( x => x . Framework ( \"net462\" ), \"f\" , \"The target framework to build for.\" )); } } flubu build -c=Debug -f=netcoreapp2.0 Extending FlubuCore fluent interface by writing your own tasks within FlubuCore plugins. public class ExampleFlubuPluginTask : TaskBase < int , ExampleFlubuPluginTask > { protected override int DoExecute ( ITaskContextInternal context ) { // Write your task logic here. return 0 ; } } Growing list of FlubuCore plugins complements built in tasks. Asynchronous execution of tasks, target dependencies and custom code. context . CreateTarget ( \"Run.Tests\" ) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName3\" )); Override existing options or add additional options to tasks through console c# context.CreateTarget(\"Example\")` .AddCoreTask(x => x.Build(\"MySolution.sln\").Configuration(\"Release\"); flubu example --configuration=Debug flubu would execute dotnet build MySolution.sln --configuration Debug Full .NET Core support including the global CLI tool dotnet tool install --global FlubuCore.GlobalTool flubu compile Possibility to test and debug your build scripts. context . WaitForDebugger (); Easily automate deployments remotely via the FlubuCore Web API. Possibility to use FlubuCore tasks in any other .NET application. FlubuCore interactive mode which offers target tab completition, options tab completition, toogle targets/options, executed commands history. It is also possible to execute external commands and operable programs. For some of them FlubuCore offers tab completion with help displayed at the bottom of console out of the box(such as dotnet, git..) Improved developer experience with FlubuCore custom analyzers.","title":"Features and Advantages"},{"location":"#getting-started","text":"Using FlubuCore is straightforward and very simple :-) It is also fully and throughly documented. The Getting Started chapter in Documentation will help you set up your first FlubuCore build in no time. You should also check getting started blog. It has some more details with some nice tips and tricks. A comprehensive list of features that FlubuCore has to offer with descriptions can be found in the Build Script Fundamentals chapter. Once you have your build and deployment scripts defined, the following Wiki chapters will explain how to run them: For .NET Framework projects use FlubuCore.Runner For .NET Core projects use FlubuCore CLI global tool","title":"Getting Started"},{"location":"#examples","text":"Aside from the detailed Wiki FlubuCore comes with example projects that reflect real-life situations. The examples can be found in the separate Examples repository . These examples will help you to get quickly start with FlubuCore: * .NET Framework build example - Example covers versioning, building the project, running tests, packaging application for deployment. .NET Core build example - Example covers versioning, building the project, running tests, packaging application for deployment. Deployment script example - Example shows how to write simple deployment script. Open source library example - Example covers versioning, building the project, running tests and publishing nuget package. It also covers how to run build script on Appveyor and Travis CI.","title":"Examples"},{"location":"#have-a-question","text":"","title":"Have a question?"},{"location":"#contributing","text":"Please see CONTRIBUTING.md .","title":"Contributing"},{"location":"#ways-to-contribute","text":"Spread the word about the project. If you like the project don't forget to give it a star so that the community get's bigger. Improve documentation. Report, fix a bug. Implement a new feature. Discuss potential ways to improve project. Improve existing implementation, performance, etc.","title":"Ways to Contribute"},{"location":"#further-development","text":"If you find FlubuCore useful (you feel it helps you on the daily basis) you can support further development by buying us a coffee (or become a backer or sponsor). Sometimes it's hard to stay awake till midnight implementing new features, coffee helps us with that. We would really appreciate your support. Money from sponsorship will also be used for the promotion of the project. If you are a backer or a sponsor you can also request for a new feature or ask for support. These issues will be handled with highest priority.","title":"Further Development"},{"location":"#backers-and-sponsors","text":"","title":"Backers and Sponsors"},{"location":"#changelog-and-roadmap","text":"Changes with description and examples can be found in Changelog. You can see FlubuCore roadmap by exploring opened Milestones.","title":"Changelog and Roadmap"},{"location":"#acknowledgements","text":"Special thanks to @ironcev for greatly improving readme and for giving some valuable advices. Special thanks to @alexinea for translating whole documentation to Chinese. Special thanks to @huanlin for writing blogs about FlubuCore in Traditional Chinese and for translating them to English.","title":"Acknowledgements"},{"location":"#net-foundation","text":"This project is supported by the .NET Foundation .","title":".NET Foundation"},{"location":"CI-Generation/","text":"feature is in beta. Available from FlubuCore 6.0.0-preview3)** \u00b6 Most of the times builds are run on contionous integration environment. With FlubuCore configuration files for Azure pipelines, Github Actions, Appveyor, Travis and Jenkins can be generated. Configuration files can be generated with command flubu {targetName} --ci={CIName} . Available CINames: Jenkins, AppVeyor, Travis, Azure, GithubActions. Seperate them with comma when generating multiple configuration files Practical sample - how to generate CI configuration file from FlubuCore build script \u00b6 Let's say we have the following build script and we want to integrate our build script into azure pipelines. public class BuildScript : DefaultBuildScript { [SolutionFileName] public string SolutionFileName { get ; set ; } = \"flubu.sln\" ; [BuildConfiguration] public string BuildConfiguration { get ; set ; } = \"Release\" ; protected override void ConfigureTargets ( ITaskContext context ) { var buildVersion = context . CreateTarget ( \"buildVersion\" ) . SetAsHidden () . SetDescription ( \"Fetches flubu version from CHANGELOG.md file.\" ) . AddTask ( x => x . FetchBuildVersionFromFileTask () . ProjectVersionFileName ( \"../CHANGELOG.md\" )); var compile = context . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the VS solution\" ) . AddCoreTask ( x => x . UpdateNetCoreVersionTask ( \"FlubuCore/FlubuCore.csproj\" , \"dotnet-flubu/dotnet-flubu.csproj\" , \"FlubuCore.Tests/FlubuCore.Tests.csproj\" , \"FlubuCore.WebApi.Model/FlubuCore.WebApi.Model.csproj\" , \"FlubuCore.WebApi.Client/FlubuCore.WebApi.Client.csproj\" , \"FlubuCore.WebApi/FlubuCore.WebApi.csproj\" , \"FlubuCore.GlobalTool/FlubuCore.GlobalTool.csproj\" )) . AddCoreTask ( x => x . Build ()) . DependsOn ( buildVersion ); var tests = context . CreateTarget ( \"test\" ) . SetDescription ( \"Runs all tests in solution.\" ) . AddCoreTask ( x => x . Test (). Project ( \"FlubuCore.Tests\\\\FlubuCore.Tests.csproj\" )) . AddCoreTask ( x => x . Test (). Project ( \"FlubuCore.WebApi.Tests\\\\FlubuCore.WebApi.Tests.csproj\" )) . AddCoreTask ( x => x . Test (). Project ( \"FlubuCore.Analyzers.Tests\\\\FlubuCore.Analyzers.Tests.csproj\" )); context . CreateTarget ( \"rebuild\" ) . SetDescription ( \"Rebuilds the solution\" ) . SetAsDefault () . DependsOn ( compile , tests ); } } We can generate Azure pipelines configuration file with command flubu Rebuild --ci=Azure . This command would generate Azure.Generated.yaml file with the following content: jobs : - job : windows_latest pool : vmimage : windows-latest steps : - task : DotNetCoreInstaller@1 displayName : Install .net core sdk inputs : version : 3.1.302 - script : dotnet tool install --global FlubuCore.Tool --version 5.1.8 displayName : Install flubu - script : flubu buildVersion --nd displayName : buildVersion - script : flubu compile --nd displayName : compile - script : flubu test --nd displayName : test - job : ubuntu_latest pool : vmimage : ubuntu-latest steps : - task : DotNetCoreInstaller@1 displayName : Install .net core sdk inputs : version : 3.1.302 - script : dotnet tool install --global FlubuCore.Tool --version 5.1.8 displayName : Install flubu - script : flubu buildVersion --nd displayName : buildVersion - script : flubu compile --nd displayName : compile - script : flubu test --nd displayName : test - job : macOs_latest pool : vmimage : macOs-latest steps : - task : DotNetCoreInstaller@1 displayName : Install .net core sdk inputs : version : 3.1.302 - script : dotnet tool install --global FlubuCore.Tool --version 5.1.8 displayName : Install flubu - script : flubu buildVersion --nd displayName : buildVersion - script : flubu compile --nd displayName : compile - script : flubu test --nd displayName : test Customizing configuration settings in CI configuration files. \u00b6 Alot of times additional configuration settings needs to be added in configuration file. Such as adding additional steps before or after flubu target execution, setting on which virtual machine image build is executed, installing additional services that are needed for build execution, setting working directory etc. This can be achived in two ways. Generated configuration file is edited manually after it is generated with flubu. Meaning generated file is used as a template and all additional configuration settings are added manually to the file. Additional configuration settings are added through fluent api in Configure method. All supported CI configuration files can be customized completly through fluent api. We wont go into details about the fluent api as we think it is self explainatory and easy to learn. public class BuildScript : DefaultBuildScript { public override void Configure ( IFlubuConfigurationBuilder configurationBuilder , ILoggerFactory loggerFactory ) { configurationBuilder . ConfigureAppVeyor ( o => o . SetCloneDepth ( 50 ) . SetVirtualMachineImage ( AppVeyorImage . VisualStudio2019 , AppVeyorImage . Ubuntu1804 ) . AddSkipCommits ( \"docs/*\" , \"assets/*\" , \"LICENCE\" , \"mkdocs.yml\" , \"README.md\" , \".travis.yml\" , \".gitignore\" , \"lang/*\" ) . SetWorkingDirectory ( \"src\" ) . AddArtifacts ( \"output/*.zip\" ) . AddCustomTarget ( \"Rebuild.Linux\" , AppVeyorImage . Ubuntu1804 )); configurationBuilder . ConfigureTravis ( t => t . AddOs ( TravisOs . Linux ) . SetDotnetVersion ( \"3.1.201\" ) . AddServices ( \"docker\" ) . AddBeforeScript ( \"sudo apt-get install dotnet-sdk-2.2\" ) . AddBeforeScript ( \"cd src\" )); configurationBuilder . ConfigureAzurePipelines ( az => az . SetWorkingDirectory ( \"src\" ) . CustomTargetsForVmImage ( AzurePipelinesImage . UbuntuLatest , \"Rebuild.Linux\" ) //// /// specified target(s) is used for flubu script generation. Script is applied only to specified image and target specified in command line is ignored for specified image. can be applied to all other CI suported servers. . CustomTargetsForVmImage ( AzurePipelinesImage . MacOsLatest , \"Rebuild.MacOs\" )); configurationBuilder . ConfigureGitHubActions ( gh => gh . SetWorkingDirectory ( \"src\" ) . OnPullRequest (). AddBranches ( \"master, develop\" ) . AddCustomStepBeforeTargets ( s => { s . Name = \"Clean\" ; ////Just a dummy example that a custom step can be added before(or after) flubu target steps. Same applies to all other CI suported servers. s . Run = \"dotnet clean\" ; })); } }","title":"Contionous integration configuration generation"},{"location":"CI-Generation/#feature-is-in-beta-available-from-flubucore-600-preview3","text":"Most of the times builds are run on contionous integration environment. With FlubuCore configuration files for Azure pipelines, Github Actions, Appveyor, Travis and Jenkins can be generated. Configuration files can be generated with command flubu {targetName} --ci={CIName} . Available CINames: Jenkins, AppVeyor, Travis, Azure, GithubActions. Seperate them with comma when generating multiple configuration files","title":"feature is in beta. Available from FlubuCore 6.0.0-preview3)**"},{"location":"CI-Generation/#practical-sample-how-to-generate-ci-configuration-file-from-flubucore-build-script","text":"Let's say we have the following build script and we want to integrate our build script into azure pipelines. public class BuildScript : DefaultBuildScript { [SolutionFileName] public string SolutionFileName { get ; set ; } = \"flubu.sln\" ; [BuildConfiguration] public string BuildConfiguration { get ; set ; } = \"Release\" ; protected override void ConfigureTargets ( ITaskContext context ) { var buildVersion = context . CreateTarget ( \"buildVersion\" ) . SetAsHidden () . SetDescription ( \"Fetches flubu version from CHANGELOG.md file.\" ) . AddTask ( x => x . FetchBuildVersionFromFileTask () . ProjectVersionFileName ( \"../CHANGELOG.md\" )); var compile = context . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the VS solution\" ) . AddCoreTask ( x => x . UpdateNetCoreVersionTask ( \"FlubuCore/FlubuCore.csproj\" , \"dotnet-flubu/dotnet-flubu.csproj\" , \"FlubuCore.Tests/FlubuCore.Tests.csproj\" , \"FlubuCore.WebApi.Model/FlubuCore.WebApi.Model.csproj\" , \"FlubuCore.WebApi.Client/FlubuCore.WebApi.Client.csproj\" , \"FlubuCore.WebApi/FlubuCore.WebApi.csproj\" , \"FlubuCore.GlobalTool/FlubuCore.GlobalTool.csproj\" )) . AddCoreTask ( x => x . Build ()) . DependsOn ( buildVersion ); var tests = context . CreateTarget ( \"test\" ) . SetDescription ( \"Runs all tests in solution.\" ) . AddCoreTask ( x => x . Test (). Project ( \"FlubuCore.Tests\\\\FlubuCore.Tests.csproj\" )) . AddCoreTask ( x => x . Test (). Project ( \"FlubuCore.WebApi.Tests\\\\FlubuCore.WebApi.Tests.csproj\" )) . AddCoreTask ( x => x . Test (). Project ( \"FlubuCore.Analyzers.Tests\\\\FlubuCore.Analyzers.Tests.csproj\" )); context . CreateTarget ( \"rebuild\" ) . SetDescription ( \"Rebuilds the solution\" ) . SetAsDefault () . DependsOn ( compile , tests ); } } We can generate Azure pipelines configuration file with command flubu Rebuild --ci=Azure . This command would generate Azure.Generated.yaml file with the following content: jobs : - job : windows_latest pool : vmimage : windows-latest steps : - task : DotNetCoreInstaller@1 displayName : Install .net core sdk inputs : version : 3.1.302 - script : dotnet tool install --global FlubuCore.Tool --version 5.1.8 displayName : Install flubu - script : flubu buildVersion --nd displayName : buildVersion - script : flubu compile --nd displayName : compile - script : flubu test --nd displayName : test - job : ubuntu_latest pool : vmimage : ubuntu-latest steps : - task : DotNetCoreInstaller@1 displayName : Install .net core sdk inputs : version : 3.1.302 - script : dotnet tool install --global FlubuCore.Tool --version 5.1.8 displayName : Install flubu - script : flubu buildVersion --nd displayName : buildVersion - script : flubu compile --nd displayName : compile - script : flubu test --nd displayName : test - job : macOs_latest pool : vmimage : macOs-latest steps : - task : DotNetCoreInstaller@1 displayName : Install .net core sdk inputs : version : 3.1.302 - script : dotnet tool install --global FlubuCore.Tool --version 5.1.8 displayName : Install flubu - script : flubu buildVersion --nd displayName : buildVersion - script : flubu compile --nd displayName : compile - script : flubu test --nd displayName : test","title":"Practical sample - how to generate CI configuration file from FlubuCore build script"},{"location":"CI-Generation/#customizing-configuration-settings-in-ci-configuration-files","text":"Alot of times additional configuration settings needs to be added in configuration file. Such as adding additional steps before or after flubu target execution, setting on which virtual machine image build is executed, installing additional services that are needed for build execution, setting working directory etc. This can be achived in two ways. Generated configuration file is edited manually after it is generated with flubu. Meaning generated file is used as a template and all additional configuration settings are added manually to the file. Additional configuration settings are added through fluent api in Configure method. All supported CI configuration files can be customized completly through fluent api. We wont go into details about the fluent api as we think it is self explainatory and easy to learn. public class BuildScript : DefaultBuildScript { public override void Configure ( IFlubuConfigurationBuilder configurationBuilder , ILoggerFactory loggerFactory ) { configurationBuilder . ConfigureAppVeyor ( o => o . SetCloneDepth ( 50 ) . SetVirtualMachineImage ( AppVeyorImage . VisualStudio2019 , AppVeyorImage . Ubuntu1804 ) . AddSkipCommits ( \"docs/*\" , \"assets/*\" , \"LICENCE\" , \"mkdocs.yml\" , \"README.md\" , \".travis.yml\" , \".gitignore\" , \"lang/*\" ) . SetWorkingDirectory ( \"src\" ) . AddArtifacts ( \"output/*.zip\" ) . AddCustomTarget ( \"Rebuild.Linux\" , AppVeyorImage . Ubuntu1804 )); configurationBuilder . ConfigureTravis ( t => t . AddOs ( TravisOs . Linux ) . SetDotnetVersion ( \"3.1.201\" ) . AddServices ( \"docker\" ) . AddBeforeScript ( \"sudo apt-get install dotnet-sdk-2.2\" ) . AddBeforeScript ( \"cd src\" )); configurationBuilder . ConfigureAzurePipelines ( az => az . SetWorkingDirectory ( \"src\" ) . CustomTargetsForVmImage ( AzurePipelinesImage . UbuntuLatest , \"Rebuild.Linux\" ) //// /// specified target(s) is used for flubu script generation. Script is applied only to specified image and target specified in command line is ignored for specified image. can be applied to all other CI suported servers. . CustomTargetsForVmImage ( AzurePipelinesImage . MacOsLatest , \"Rebuild.MacOs\" )); configurationBuilder . ConfigureGitHubActions ( gh => gh . SetWorkingDirectory ( \"src\" ) . OnPullRequest (). AddBranches ( \"master, develop\" ) . AddCustomStepBeforeTargets ( s => { s . Name = \"Clean\" ; ////Just a dummy example that a custom step can be added before(or after) flubu target steps. Same applies to all other CI suported servers. s . Run = \"dotnet clean\" ; })); } }","title":"Customizing configuration settings in CI configuration files."},{"location":"Tests-debugging/","text":"Debug script through .net core console application \u00b6 The easiest way to debug your script is that you place your script in a console application and execute it in console application. After that you can debug your script as any other application. How to execute scripts through console application can be found here. Writing build script tests and debuging build script through test \u00b6 Wiki coming soon. Meanwhile see simple test on github to get you started: If needed you can debug build script through test. You can use flubu task in other .net applications just like in above test example. Debugging build script by attaching to running process \u00b6 You can debug build script by attaching debuger to Flubu process. Because Flubu alters build script slightly you have to disable option 'Require source code files to exactly match the original version' in visual studio. Option can be found under Tools->Options->Debugging->General->Require source code files to exactly match the original version. Not sure for VS code if any settings have to be changed. It is advised to use WaitForDebugger extension method on ITaskContext before first break point 1 2 3 4 protected override void ConfigureTargets(ITaskContext context) { context.WaitForDebugger(); } Run build script and attach debugger to FlubuCore process. FlubuCore process name vary depending on which FlubuCore \"runner\" you are using. FlubuCore.Runner - You have to attach debugger to process named flubu.exe dotnet-flubu Cli tool - You have to attach debugger to right process named dotnet FlubuCore.GlobalTool - You have to attach debugger to process named Flubu","title":"Tests and debuging"},{"location":"Tests-debugging/#debug-script-through-net-core-console-application","text":"The easiest way to debug your script is that you place your script in a console application and execute it in console application. After that you can debug your script as any other application. How to execute scripts through console application can be found here.","title":"Debug script through .net core console application"},{"location":"Tests-debugging/#writing-build-script-tests-and-debuging-build-script-through-test","text":"Wiki coming soon. Meanwhile see simple test on github to get you started: If needed you can debug build script through test. You can use flubu task in other .net applications just like in above test example.","title":"Writing build script tests and debuging build script through test"},{"location":"Tests-debugging/#debugging-build-script-by-attaching-to-running-process","text":"You can debug build script by attaching debuger to Flubu process. Because Flubu alters build script slightly you have to disable option 'Require source code files to exactly match the original version' in visual studio. Option can be found under Tools->Options->Debugging->General->Require source code files to exactly match the original version. Not sure for VS code if any settings have to be changed. It is advised to use WaitForDebugger extension method on ITaskContext before first break point 1 2 3 4 protected override void ConfigureTargets(ITaskContext context) { context.WaitForDebugger(); } Run build script and attach debugger to FlubuCore process. FlubuCore process name vary depending on which FlubuCore \"runner\" you are using. FlubuCore.Runner - You have to attach debugger to process named flubu.exe dotnet-flubu Cli tool - You have to attach debugger to right process named dotnet FlubuCore.GlobalTool - You have to attach debugger to process named Flubu","title":"Debugging build script by attaching to running process"},{"location":"build-script-runner-interactive/","text":"When executing flubu script or any other process locally in console it is recomended to run FlubuCore in interactive mode it gives you some really nice features which are listed in the features section. To start FlubuCore interactive mode just execute command flubu -i in your favorite console. Demo \u00b6 Build script used in demo. Features \u00b6 Features in interactive mode Target's tab completition with tab key Option's (parameter) tab completition with tab key Option's (parameter) value tab completition with tab key for enum types Target help displayed at the bottom of console Option help displayed at the bottom of console Execute external commands. Meaning if you run FlubuCore interactive mode for example in powershell all powershell commands are available in FlubuCore interactive mode. Execute external processes. For some of them FlubuCore offers tab completion with help at the bottom of console out of the box(such as dotnet, git... See full list ) Next / previos target with up and down arrow Next / previos option with up and down arrow Next / previos target or option with tab key History of executed commans with up and down arrow No need to load script for each executed target reload or load another script Navigation beatwen folders Internal commands \u00b6 cd change directory. dir list files and directories l|load -s={script} Load another FlubuCore script. r|reload Reload currently loaded script. e|q|exit|quit Exit Flubu Core interactive mode. Hot keys \u00b6 Following hot keys are supported: Enter Executes entered command Tab completes user's input with active target/option hint (if found) Up arrow select previous command from history if user's input is empty or select previous hint (if possible) Down arrow select next command from history if user's input is empty or select next hint (if possible) Left arrow move cursor left Right arrow move cursor right Backspace removes character before cursor Delete removes character under cursor Home move cursor to the beginning of user's input End move cursor to the end of user's input External processes tab completion list \u00b6 List of external processes for which tab completion of options/switches is available in FlubuCore interactive mode. it is planned that all docker, octopus, azure, npm and chocolatey commands will also be supported in the near feature. dotnet build dotnet test dotnet pack dotnet publish dotnet nuget push dotnet restore dotnet tool install dotnet tool update dotnet tool uniinstall git add git commit git push git checkout git clone git submodule git rm git tag gitversion coverlet sqlcmd.exe","title":"Build script runner interactive mode"},{"location":"build-script-runner-interactive/#demo","text":"Build script used in demo.","title":"Demo"},{"location":"build-script-runner-interactive/#features","text":"Features in interactive mode Target's tab completition with tab key Option's (parameter) tab completition with tab key Option's (parameter) value tab completition with tab key for enum types Target help displayed at the bottom of console Option help displayed at the bottom of console Execute external commands. Meaning if you run FlubuCore interactive mode for example in powershell all powershell commands are available in FlubuCore interactive mode. Execute external processes. For some of them FlubuCore offers tab completion with help at the bottom of console out of the box(such as dotnet, git... See full list ) Next / previos target with up and down arrow Next / previos option with up and down arrow Next / previos target or option with tab key History of executed commans with up and down arrow No need to load script for each executed target reload or load another script Navigation beatwen folders","title":"Features"},{"location":"build-script-runner-interactive/#internal-commands","text":"cd change directory. dir list files and directories l|load -s={script} Load another FlubuCore script. r|reload Reload currently loaded script. e|q|exit|quit Exit Flubu Core interactive mode.","title":"Internal commands"},{"location":"build-script-runner-interactive/#hot-keys","text":"Following hot keys are supported: Enter Executes entered command Tab completes user's input with active target/option hint (if found) Up arrow select previous command from history if user's input is empty or select previous hint (if possible) Down arrow select next command from history if user's input is empty or select next hint (if possible) Left arrow move cursor left Right arrow move cursor right Backspace removes character before cursor Delete removes character under cursor Home move cursor to the beginning of user's input End move cursor to the end of user's input","title":"Hot keys"},{"location":"build-script-runner-interactive/#external-processes-tab-completion-list","text":"List of external processes for which tab completion of options/switches is available in FlubuCore interactive mode. it is planned that all docker, octopus, azure, npm and chocolatey commands will also be supported in the near feature. dotnet build dotnet test dotnet pack dotnet publish dotnet nuget push dotnet restore dotnet tool install dotnet tool update dotnet tool uniinstall git add git commit git push git checkout git clone git submodule git rm git tag gitversion coverlet sqlcmd.exe","title":"External processes tab completion list"},{"location":"build-script-runner/","text":"In .NET you run flubu build scripts with console application flubu.exe. Add Flubu.Runner nuget to get the console application. In .NET core you run flubu build scripts with dotnet command line tool or global tool. How to install tools see Getting started section Usage \u00b6 .NET core usage: dotnet flubu {TargetToExecute} {Flubu options} {build script arguments} .NET core global tool usage: flubu {TargetToExecute} {Flubu options} {build script arguments} .NET usage: flubu.exe {TargetToExecute} {Flubu options} {build script arguments} Multiple target execution \u00b6 .NET core usage: dotnet flubu {TargetToExecute} {TargetToExecute2} {TargetToExecute3...} {Options} .NET usage: flubu.exe {TargetToExecute} {TargetToExecute2} {TargetToExecute3...} {Options} Target's can be executed in parallel with added -parallel option Flubu options \u00b6 target help \u00b6 List all available targets: flubu help dotnet flubu help Target specific help: flubu {TargetName} help dotnet flubu {TargetName} help It displays all tasks with description that will be executed by target. It also displays which argument(with description) can be passed through to specific task in target. Specifiying which script Flubu should run. \u00b6 Easiest way is to put build script at one of the default locations (you can find list of default locations below). If it is located at one of the default locations FlubuCore will execute the script automatically flubu {TargetName} . Second option is to specify script location with -s option flubu {TargetName} -s={pathToScriptFile} Third option is to run flubu setup and specify script and csproj(optional) location in interactive mode. Flubu will store script and csproj location to .flubu file. if .flubu file is present FlubuCore will read location of the script and csproj file from that file. Additional benefit when storing location to .flubu file is that you don't need to execute script at the root directory of the project. Meaning if your project is for example located at \"c:_git\\myproject\" you can execute script inside any subfolder of that location. The location where a .flubu file is found will be used as the \"work directory\" during a build process, and a correct \"work directory\" is crucial to use relative paths in our build scripts. Default build script locations \u00b6 \"Build.cs\" \u201cBuildScript.cs\u201d \u201cDeployScript.cs\u201d \"DeploymentScript.cs\" \"_Build/Build.cs\" \"_Build/BuildScript.cs\" \"Build/Build.cs\" \"Build/BuildScript.cs\" \"_BuildScript/BuildScript.cs\" \"_BuildScripts/BuildScript.cs\" \u201cBuildScript/BuildScript.cs\u201d \u201cbuildscript/deployscript.cs\u201d \u201cbuildscripts/buildscript.cs\u201d \u201cbuildscripts/deployscript.cs\u201d \"BuildScript/DeploymentScript.cs\" \"BuildScripts/DeploymentScript.cs\"","title":"Build script runner"},{"location":"build-script-runner/#usage","text":".NET core usage: dotnet flubu {TargetToExecute} {Flubu options} {build script arguments} .NET core global tool usage: flubu {TargetToExecute} {Flubu options} {build script arguments} .NET usage: flubu.exe {TargetToExecute} {Flubu options} {build script arguments}","title":"Usage"},{"location":"build-script-runner/#multiple-target-execution","text":".NET core usage: dotnet flubu {TargetToExecute} {TargetToExecute2} {TargetToExecute3...} {Options} .NET usage: flubu.exe {TargetToExecute} {TargetToExecute2} {TargetToExecute3...} {Options} Target's can be executed in parallel with added -parallel option","title":"Multiple target execution"},{"location":"build-script-runner/#flubu-options","text":"","title":"Flubu options"},{"location":"build-script-runner/#target-help","text":"List all available targets: flubu help dotnet flubu help Target specific help: flubu {TargetName} help dotnet flubu {TargetName} help It displays all tasks with description that will be executed by target. It also displays which argument(with description) can be passed through to specific task in target.","title":"target help"},{"location":"build-script-runner/#specifiying-which-script-flubu-should-run","text":"Easiest way is to put build script at one of the default locations (you can find list of default locations below). If it is located at one of the default locations FlubuCore will execute the script automatically flubu {TargetName} . Second option is to specify script location with -s option flubu {TargetName} -s={pathToScriptFile} Third option is to run flubu setup and specify script and csproj(optional) location in interactive mode. Flubu will store script and csproj location to .flubu file. if .flubu file is present FlubuCore will read location of the script and csproj file from that file. Additional benefit when storing location to .flubu file is that you don't need to execute script at the root directory of the project. Meaning if your project is for example located at \"c:_git\\myproject\" you can execute script inside any subfolder of that location. The location where a .flubu file is found will be used as the \"work directory\" during a build process, and a correct \"work directory\" is crucial to use relative paths in our build scripts.","title":"Specifiying which script Flubu should run."},{"location":"build-script-runner/#default-build-script-locations","text":"\"Build.cs\" \u201cBuildScript.cs\u201d \u201cDeployScript.cs\u201d \"DeploymentScript.cs\" \"_Build/Build.cs\" \"_Build/BuildScript.cs\" \"Build/Build.cs\" \"Build/BuildScript.cs\" \"_BuildScript/BuildScript.cs\" \"_BuildScripts/BuildScript.cs\" \u201cBuildScript/BuildScript.cs\u201d \u201cbuildscript/deployscript.cs\u201d \u201cbuildscripts/buildscript.cs\u201d \u201cbuildscripts/deployscript.cs\u201d \"BuildScript/DeploymentScript.cs\" \"BuildScripts/DeploymentScript.cs\"","title":"Default build script locations"},{"location":"buildscript-fundamentals/","text":"Build script \u00b6 Each build script should inherit from DefaulBuildScript class. Two abstact methods from DefaultBuildScript have to be implemented. ConfigureTargets: Here you can create new targets that will perform specific work. Empty build script example public class BuildScript : DefaultBuildScript { protected override void ConfigureTargets ( ITaskContext session ) { } } Targets \u00b6 Targets are used to perform specific work in a specific order. A target can for example execute flubu built in tasks like a task for compiling the solution or it can execute some custom csharp code. Target can also have dependencies on other targets. Create a new Target \u00b6 Following code will create a new target that will execute a built in task. protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Compile\" ) . SetDescription ( \"Compiles the solution\" ) . AddTask ( x => x . CompileSolutionTask ()); } After target is defined. Target can be executed from console Flubu compile Target's can also be defined with attributes on method. [Target(\"targetName\", \"a\", \"b\")] [Target(\"targetName2\", \"c\", \"d\")] [Target(\"targetName3\", \"e\", \"f\")] public void Example ( ITarget target , string source , string destination ) { target . AddTask ( x => x . CopyFileTask ( source , destination , true )); } You can also pass values to parameter through console arguments or FlubuCore config file. Flubu targetName2 -destination=SomeOtherDestination Tasks \u00b6 Tasks are divided in tasks and core tasks. tasks can be executed in .net and .net core projects. Core tasks can only be executed in .net core projects. Following example executes 2 core tasks in a target. Order of execution is the same as specified in code. context . CreateTarget ( \"Build\" ) . AddCoreTask ( x => x . Restore ()) . AddCoreTask ( x => x . Build ()); All Tasks have following methods: .OnError((c, ex) => { c.LogInfo(\"Example\");})) - onError can perform some custom action when error occurs on specific task. .Retry(5, 1000) - Retry mechanism. You can apply specific condition when retry mechanism will retry task. .Finally(c => { c.LogInfo(\"Example\");})) - Finally block acts just like finally in try catch. .DoNotFailOnError() - script does not fail in case of exception. You can apply specific condition when task will not fail. .NoLog() - Task doesn't log anything to console output. .SetDescription() - Overrides the default help description of the task. .ForMember() - pass through console argument to method or property. See Pass console arguments, settings from json configuration file, environment variables with ForMember to tasks for more details. conditonal task execution with when cluase on single task (see bellow for group of tasks) context . CreateTarget ( \"Example\" ) . AddTask ( x => x . CompileSolutionTask ()) . AddTask ( x => x . PublishNuGetPackageTask ( \"packageId\" , \"pathToNuspec\" )) . When ( c => c . BuildSystems (). Jenkins (). IsRunningOnJenkins ); set task parameters only when specified condition is meet. var compile = context . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the VS solution\" ) . AddCoreTask ( x => x . Build (). Configuration ( \"Release\" ) . When ( () => { return context . BuildSystems (). IsLocalBuild ; }, task => { task . Configuration ( \"Debug\" ); })); .Interactive() - Interactively pass argument from console to specified task method / parameter. Task attributes (Versioning) \u00b6 It is possible to execute some tasks with attribute on property Flubu will inject return value of the task to the property. This is especially usefull for all versioning tasks, basically all tasks that return a value. See FlubuCore.Tasks.Attributes namespace for all available attributes. [FetchBuildVersionFromFile] public BuildVersion BuildVersion { get ; } [GitVersion] public GitVersion GitVersion { get ; } This allows you to access version information in ConfigureTarget which is not possible if versioning task is executed for example as target dependency protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Build\" ) . AddCoreTask ( x => x . Build (). Version ( BuildVersion . Version . ToString ())); } Write custom c# code (custom tasks) \u00b6 Following example executes custom code. You can also use built in flubu tasks in custom code as shown in example. protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Example\" ) . Do ( CustomCodeExample ); } private static void CustomCodeExample ( ITaskContext context ) { //// You can put any c# code here and use any .net libraries. Console . WriteLine ( \"Dummy custom code\" ); context . Tasks (). NUnitTaskForNunitV3 ( \"project name\" ). Execute ( context ); } You can also add parameters to methods: protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Example\" ) . Do ( CustomCodeExample , \"some value\" , 1 ); } private static void CustomCodeExample ( ITaskContext context , string arg1 , int arg2 ) { Console . WriteLine ( \"Dummy custom code\" ); context . Tasks (). NUnitTaskForNunitV3 ( \"project name\" ). Execute ( context ); } Target dependencies \u00b6 Target can have dependencies on other targets. All dependenies will be executed before target in the specified order. When targetC is executed target\u2019s will execute in the following order: TargetB, TargetA, TargetC var targetA = context . CreateTarget ( \"TargetA\" ); var targetB = context . CreateTarget ( \"TargetB\" ); var targetC = context . CreateTarget ( \"TargetC\" ). DependsOn ( targetB , targetA ); It is also possible to reverse dependency var targetC = context . CreateTarget ( \"TargetC\" ). DependenceOf ( targetA ); Add target to target \u00b6 Target can be executed within other target with AddTarget. Target is executed in the order it was added Example: protected override void ConfigureTargets ( ITaskContext context ) { var exampleB = context . CreateTarget ( \"TargetB\" ) . Do ( Something ); context . CreateTarget ( \"TargetA\" ) . AddCoreTask ( x => x . Build ()) . AddTarget ( exampleB ) . Do ( JustAnExample ); } public void JustAnExample ( ITaskContext context ) { ... } following execution order is taken when TargetA is executed Build task TargetB target JustAnExample method Reuse set of tasks in different targets \u00b6 Following example shows how to reuse set of tasks in different targets: protected override void ConfigureTargets ( ITaskContext session ) { session . CreateTarget ( \"deploy.local\" ). AddTasks ( Deploy , \"c:\\\\ExamplaApp\" ). SetAsDefault (); session . CreateTarget ( \"deploy.test\" ). AddTasks ( Deploy , \"d:\\\\ExamplaApp\" ); session . CreateTarget ( \"deploy.prod\" ). AddTasks ( Deploy , \"e:\\\\ExamplaApp\" ); } private void Deploy ( ITarget target , string deployPath ) { target . AddTask ( x => x . IisTasks (). CreateAppPoolTask ( \"Example app pool\" ). Mode ( CreateApplicationPoolMode . DoNothingIfExists )) . AddTask ( x => x . IisTasks (). ControlAppPoolTask ( \"Example app pool\" , ControlApplicationPoolAction . Stop ). DoNotFailOnError ()) . Do ( UnzipPackage ) . AddTask ( x => x . CopyDirectoryStructureTask ( @\"Packages\\ExampleApp\" , @\"C:\\ExampleApp\" , true ). Retry ( 20 , 5000 )) . Do ( CreateWebSite ) } Add tasks to target with a foreach loop \u00b6 Following example shows how to add multiple tasks to target with a foreach loop protected override void ConfigureTargets ( ITaskContext context ) { var solution = context . GetVsSolution (); context . CreateTarget ( \"Pack\" ) . ForEach ( solution . Projects , ( item , target ) => { target . AddCoreTask ( x => x . Pack (). Project ( item . ProjectName )) . Do ( JustAnExample , item ); }); } private void JustAnExample ( ITaskContext context , VSProjectInfo vsProjectInfo ) { //// Do something. } Example will execute Pack task for each project in solution. Group tasks and apply When, OnError, Finally on them \u00b6 Conditonal task execution with When clause on group of tasks. protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Example\" ) . AddCoreTask ( x => x . Build ()) . Group ( target => { target . AddCoreTask ( x => x . Pack ()); target . AddCoreTask ( x => x . NugetPush ( \"pathToPackage\" )); }, when : c => ! c . BuildSystems (). Jenkins (). IsRunningOnJenkins ); } Finally on group of tasks: onFinally acts just like finally in try/catch. context . CreateTarget ( \"Example\" ) . AddCoreTask ( x => x . Build ()) . Group ( target => { target . AddCoreTask ( x => x . Pack ()); target . AddCoreTask ( x => x . NugetPush ( \"pathToPackage\" )); }, onFinally : c => { c . Tasks (). DeleteFilesTask ( \"pathToNupkg\" , \"*.*\" , true ). Execute ( c ); }); OnError on group of tasks: You can perform some custom action when error occures in any of tasks that are in group. context . CreateTarget ( \"Example\" ) . AddCoreTask ( x => x . Build ()) . Group ( target => { target . AddCoreTask ( x => x . Pack ()); target . AddCoreTask ( x => x . NugetPush ( \"pathToPackage\" )); }, onError : ( c , error ) => { //// some custom action when error occures in any of the task in group. }); Asynchronus or parallel execution of tasks, customCode and dependencies \u00b6 Tasks can be executed asynchrounously or in parallel with AddTaskAsync or AddCoreTaskAsync method. Custom code can be executed asynchrounosly with DoAsync method. Dependencies can be executed asynchrounosly with DependsOnAsync method. Following target executes 3 tasks in parallel. session . CreateTarget ( \"run.tests\" ) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName3\" )); Async and sync methods can also be mixed session . CreateTarget ( \"async.example\" ) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . Do ( SomeCustomMethod ) . DoAsync ( SomeCustomAsyncMethod2 ) . DoAsync ( SomeCustomAsyncMethod3 ); The code above will first execute 2 nunit tasks asynchronously and wait for both tasks to finish. Then it will execute SomeCustomMethod synchrounosly. After it is finished code from SomeCustomAsyncMethod2 and SomeCustomAsyncMethod3 will be executed in parallel. sequential logging in asynchronus executed tasks and targets \u00b6 Usually logs are not readable when executing more than 1 task asynchronously or in parallel. That's why FlubuCore offers sequential logging in asynchronus tasks. You can enable them with .SequentialLogging(true) on target. It has to be placed before asynchronus tasks/target dependencies otherwise logs will not be sequential. context . CreateTarget ( \"Test\" ) . SetAsDefault () . SequentialLogging ( true ) . AddCoreTaskAsync ( x => x . Pack ()) . AddCoreTaskAsync ( x => x . Pack ()) . DependsOnAsync ( test2 , test3 ); Target executed in parallel with FlubuCore runner have sequential logging on by default. flubu target1 target2 --parallel Other features \u00b6 Target features \u00b6 SetAsDefault method: When applied to target that target is runned by default if no target is specified when running the script with runner. SetAsHidden method: When applied to target that target is not shown in help and it can only be run as other target dependency. Must method: Condition in must will have to be meet otherwise target execution will fail before any task get executed. Requires method: Parameter specified in required method must not be null otherwise target execution will fail before any task get executed. Context features \u00b6 Log: context.LogInfo(\"Some Text2\", ConsoleColor.Blue); GetVsSolution: Get's solution and it's projects information(such as full project path, target framework, runtimeidentifier..) context.GetVsSolution(); GetFiles: Get Files from specified directory with option to filter files with glob pattern context.GetFiles(OutputDirectory, \"*.nupkg\"); GetDirectories: Get Directories from specified directory with option to filter files with glob pattern context.GetFiles(OutputDirectory, \"*.nupkg\"); GetEnviromentVariable method: Get's the enviroment variable by name context.GetEnvironmentVariable(\"someVariable\"); Run any program or command in build script with RunProgramTask \u00b6 protected override void ConfigureTargets ( ITaskContext session ) { var runExternalProgramExample = session . CreateTarget ( \"run.libz\" ) . AddTask ( x => x . RunProgramTask ( @\"packages\\LibZ.Tool\\1.2.0\\tools\\libz.exe\" ) . WorkingFolder ( @\".\\src\" ) . WithArguments ( \"add\" ) . WithArguments ( \"--libz\" , \"Assemblies.libz\" )); } Linux Example: protected override void ConfigureTargets ( ITaskContext context ) { var runExternalProgramExample = context . CreateTarget ( \"systemctl.example\" ) AddTask ( x => x . RunProgramTask ( @\"systemctl\" ) . WithArguments ( \"start\" ) . WithArguments ( \"nginx.service\" )); } Build properties \u00b6 You can define various build properties with Attributes on properties or in ConfigureBuildProperties method (old way) to share them in different tasks and custom code. Following example shows how to share solution file name and configuration across various targets/tasks. [SolutionFileName] public string SolutionFileName { get ; set ; } = \"FlubuExample.sln\" ; [BuildConfiguration] public string BuildConfiguration { get ; set ; } = \"Release\" ; protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"build\" ) . AddCoreTask ( x => x . Build ()); context . CreateTarget ( \"pack\" ) . AddCoreTask ( x => x . Pack ()); } Alternative: [BuildProperty(BuildProps.BuildConfiguration)] public string BuildConfiguration { get ; set ; } = \"Release\" ; If Solution file name and path would not be set through build property attributes you would have to set it in each task separately. like so: protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"build\" ) . AddCoreTask ( x => x . Build () . Project ( \"FlubuExample.sln\" ) . Configuration ( \"Release\" )); context . CreateTarget ( \"pack\" ) . AddCoreTask ( x => x . Pack () . Project ( \"FlubuExample.sln\" ) . Configuration ( \"Release\" )); } Predefined build properties \u00b6 Some build properties are already defined. You can access them through interface: context.Properties.Get(PredefinedBuildProperties.OsPlatform); Available predefined build properties: OsPlatform PathToDotnetExecutable UserProfileFolder OutputDir ProductRootDir All of them can be overriden. Pass command line arguments, settings from json configuration file or environment variables to your build script properties. \u00b6 You can pass command line arguments, settings from json configuration file or environment variables to your build script properties by adding FromArg attribute to property. public class SimpleScript : DefaultBuildScript { [FromArg(\"sn\", \"If true app is deployed on second node. Otherwise not.\")] public bool deployOnSecondNode { get ; set ; } protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Deploy.Exapmle\" ) . AddTask ( x => x . FlubuWebApiTasks (). GetTokenTask ( \"user\" , \"pass\" ). SetWebApiBaseUrl ( \"noade1Url\" )) . AddTask ( x => x . FlubuWebApiTasks (). UploadPackageTask ( \"packageDir\" , \"*.zip\" )) . AddTask ( x => x . FlubuWebApiTasks (). ExecuteScriptTask ( \"Deploy\" , \"DeployScript.cs\" )) . Group ( target => { target . AddTask ( x => x . FlubuWebApiTasks (). GetTokenTask ( \"user\" , \"pass\" ). SetWebApiBaseUrl ( \"noade2Url\" )) . AddTask ( x => x . FlubuWebApiTasks (). UploadPackageTask ( \"packageDir\" , \"*.zip\" )) . AddTask ( x => x . FlubuWebApiTasks (). ExecuteScriptTask ( \"Deploy\" , \"DeployScript.cs\" )); }, when : c => deployOnSecondNode ); } } First parameter in FromArg attribute is the argument key. Second is the help description of the property shown in flubu runner. You actually don't need to put attribute on property. If u dont then the key is the same as property name and help is not shown for property in build script runner. Property types that are supported: string, boolean, int, long, decimal, double, DateTime. Passing command line argument to build script property. \u00b6 Dotnet flubu Deploy.Example -sn=true Passing setting from json configuration file to build script property \u00b6 Create file FlubuSettings.json where Flubu runner is located. Add argument key and value to file in json format. For above example json file would look like this: { \"sn\" : true , \"SomeOtherKey\" : \"SomeOtherValue\" } It's typical to have different configuration settings for different environments for example development, testing, and production. Just create different json files FlubuSettings.{Environment}.Json and set enviroment variable 'ASPNETCORE_ENVIRONMENT' on desired machine You can also create json configuration file by machine name FlubuSettings.{MachineName}.Json . If MachineName in file matches the machine name Flubu will automatically read settings from that file. Passing enviroment variable to build script property \u00b6 You can also set script arguments through environment variables. environment variables must have prefix flubu_ For above example you would add environment variable from windows command line with the following command: set flubu_sn=true Pass console arguments, settings from json configuration file, environment variables with ForMember to tasks. \u00b6 There is an alternative more sophisticated way to pass console arguments, settings and environment variables to tasks protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"compile\" ) . AddTask ( x => x . CompileSolutionTask () . ForMember ( y => y . SolutionFileName ( \"someSolution.sln\" ), \"solution\" , \"The solution to build.\" )); } First parameter is the method or property argument that will be passed through. values set in method parameters are default values if argument is not specified when running the build script. Second parameter is the argument key. Third optional parameter is help that will be displayed in detailed target help. If parameter is not set then default generated help will be displayed. Dotnet flubu compile -solution=someothersolution.sln Build system providers \u00b6 You can acces various build, commit... information for various build systems (such as Jenkins, TeamCity, AppVeyor, Travis...) protected override void ConfigureTargets ( ITaskContext context ) { bool isLocalBuild = context . BuildSystems (). IsLocalBuild ; var gitCommitId = context . BuildSystems (). Jenkins (). GitCommitId ; } Build events \u00b6 OnBuildFailed event: public class BuildScript : DefaultBuildScript { protected override void OnBuildFailed ( ITaskSession session , Exception ex ) { } } before and after target execution events: protected override void BeforeTargetExecution ( ITaskContext context ) { } protected override void AfterTargetExecution ( ITaskContext context ) { } before and after build execution events: protected override void BeforeBuildExecution ( ITaskContext context ) { } protected override void AfterBuildExecution ( ITaskSession session ) { } Partial and base class in script \u00b6 Partial and base classes are loaded automatically if they are located in the same directory as buildscript. Otherwise they have to be added with Include attribute .","title":"Build script fundamentals"},{"location":"buildscript-fundamentals/#build-script","text":"Each build script should inherit from DefaulBuildScript class. Two abstact methods from DefaultBuildScript have to be implemented. ConfigureTargets: Here you can create new targets that will perform specific work. Empty build script example public class BuildScript : DefaultBuildScript { protected override void ConfigureTargets ( ITaskContext session ) { } }","title":"Build script"},{"location":"buildscript-fundamentals/#targets","text":"Targets are used to perform specific work in a specific order. A target can for example execute flubu built in tasks like a task for compiling the solution or it can execute some custom csharp code. Target can also have dependencies on other targets.","title":"Targets"},{"location":"buildscript-fundamentals/#create-a-new-target","text":"Following code will create a new target that will execute a built in task. protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Compile\" ) . SetDescription ( \"Compiles the solution\" ) . AddTask ( x => x . CompileSolutionTask ()); } After target is defined. Target can be executed from console Flubu compile Target's can also be defined with attributes on method. [Target(\"targetName\", \"a\", \"b\")] [Target(\"targetName2\", \"c\", \"d\")] [Target(\"targetName3\", \"e\", \"f\")] public void Example ( ITarget target , string source , string destination ) { target . AddTask ( x => x . CopyFileTask ( source , destination , true )); } You can also pass values to parameter through console arguments or FlubuCore config file. Flubu targetName2 -destination=SomeOtherDestination","title":"Create a new Target"},{"location":"buildscript-fundamentals/#tasks","text":"Tasks are divided in tasks and core tasks. tasks can be executed in .net and .net core projects. Core tasks can only be executed in .net core projects. Following example executes 2 core tasks in a target. Order of execution is the same as specified in code. context . CreateTarget ( \"Build\" ) . AddCoreTask ( x => x . Restore ()) . AddCoreTask ( x => x . Build ()); All Tasks have following methods: .OnError((c, ex) => { c.LogInfo(\"Example\");})) - onError can perform some custom action when error occurs on specific task. .Retry(5, 1000) - Retry mechanism. You can apply specific condition when retry mechanism will retry task. .Finally(c => { c.LogInfo(\"Example\");})) - Finally block acts just like finally in try catch. .DoNotFailOnError() - script does not fail in case of exception. You can apply specific condition when task will not fail. .NoLog() - Task doesn't log anything to console output. .SetDescription() - Overrides the default help description of the task. .ForMember() - pass through console argument to method or property. See Pass console arguments, settings from json configuration file, environment variables with ForMember to tasks for more details. conditonal task execution with when cluase on single task (see bellow for group of tasks) context . CreateTarget ( \"Example\" ) . AddTask ( x => x . CompileSolutionTask ()) . AddTask ( x => x . PublishNuGetPackageTask ( \"packageId\" , \"pathToNuspec\" )) . When ( c => c . BuildSystems (). Jenkins (). IsRunningOnJenkins ); set task parameters only when specified condition is meet. var compile = context . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the VS solution\" ) . AddCoreTask ( x => x . Build (). Configuration ( \"Release\" ) . When ( () => { return context . BuildSystems (). IsLocalBuild ; }, task => { task . Configuration ( \"Debug\" ); })); .Interactive() - Interactively pass argument from console to specified task method / parameter.","title":"Tasks"},{"location":"buildscript-fundamentals/#task-attributes-versioning","text":"It is possible to execute some tasks with attribute on property Flubu will inject return value of the task to the property. This is especially usefull for all versioning tasks, basically all tasks that return a value. See FlubuCore.Tasks.Attributes namespace for all available attributes. [FetchBuildVersionFromFile] public BuildVersion BuildVersion { get ; } [GitVersion] public GitVersion GitVersion { get ; } This allows you to access version information in ConfigureTarget which is not possible if versioning task is executed for example as target dependency protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Build\" ) . AddCoreTask ( x => x . Build (). Version ( BuildVersion . Version . ToString ())); }","title":"Task attributes (Versioning)"},{"location":"buildscript-fundamentals/#write-custom-c-code-custom-tasks","text":"Following example executes custom code. You can also use built in flubu tasks in custom code as shown in example. protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Example\" ) . Do ( CustomCodeExample ); } private static void CustomCodeExample ( ITaskContext context ) { //// You can put any c# code here and use any .net libraries. Console . WriteLine ( \"Dummy custom code\" ); context . Tasks (). NUnitTaskForNunitV3 ( \"project name\" ). Execute ( context ); } You can also add parameters to methods: protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Example\" ) . Do ( CustomCodeExample , \"some value\" , 1 ); } private static void CustomCodeExample ( ITaskContext context , string arg1 , int arg2 ) { Console . WriteLine ( \"Dummy custom code\" ); context . Tasks (). NUnitTaskForNunitV3 ( \"project name\" ). Execute ( context ); }","title":"Write custom c# code (custom tasks)"},{"location":"buildscript-fundamentals/#target-dependencies","text":"Target can have dependencies on other targets. All dependenies will be executed before target in the specified order. When targetC is executed target\u2019s will execute in the following order: TargetB, TargetA, TargetC var targetA = context . CreateTarget ( \"TargetA\" ); var targetB = context . CreateTarget ( \"TargetB\" ); var targetC = context . CreateTarget ( \"TargetC\" ). DependsOn ( targetB , targetA ); It is also possible to reverse dependency var targetC = context . CreateTarget ( \"TargetC\" ). DependenceOf ( targetA );","title":"Target dependencies"},{"location":"buildscript-fundamentals/#add-target-to-target","text":"Target can be executed within other target with AddTarget. Target is executed in the order it was added Example: protected override void ConfigureTargets ( ITaskContext context ) { var exampleB = context . CreateTarget ( \"TargetB\" ) . Do ( Something ); context . CreateTarget ( \"TargetA\" ) . AddCoreTask ( x => x . Build ()) . AddTarget ( exampleB ) . Do ( JustAnExample ); } public void JustAnExample ( ITaskContext context ) { ... } following execution order is taken when TargetA is executed Build task TargetB target JustAnExample method","title":"Add target to target"},{"location":"buildscript-fundamentals/#reuse-set-of-tasks-in-different-targets","text":"Following example shows how to reuse set of tasks in different targets: protected override void ConfigureTargets ( ITaskContext session ) { session . CreateTarget ( \"deploy.local\" ). AddTasks ( Deploy , \"c:\\\\ExamplaApp\" ). SetAsDefault (); session . CreateTarget ( \"deploy.test\" ). AddTasks ( Deploy , \"d:\\\\ExamplaApp\" ); session . CreateTarget ( \"deploy.prod\" ). AddTasks ( Deploy , \"e:\\\\ExamplaApp\" ); } private void Deploy ( ITarget target , string deployPath ) { target . AddTask ( x => x . IisTasks (). CreateAppPoolTask ( \"Example app pool\" ). Mode ( CreateApplicationPoolMode . DoNothingIfExists )) . AddTask ( x => x . IisTasks (). ControlAppPoolTask ( \"Example app pool\" , ControlApplicationPoolAction . Stop ). DoNotFailOnError ()) . Do ( UnzipPackage ) . AddTask ( x => x . CopyDirectoryStructureTask ( @\"Packages\\ExampleApp\" , @\"C:\\ExampleApp\" , true ). Retry ( 20 , 5000 )) . Do ( CreateWebSite ) }","title":"Reuse set of tasks in different targets"},{"location":"buildscript-fundamentals/#add-tasks-to-target-with-a-foreach-loop","text":"Following example shows how to add multiple tasks to target with a foreach loop protected override void ConfigureTargets ( ITaskContext context ) { var solution = context . GetVsSolution (); context . CreateTarget ( \"Pack\" ) . ForEach ( solution . Projects , ( item , target ) => { target . AddCoreTask ( x => x . Pack (). Project ( item . ProjectName )) . Do ( JustAnExample , item ); }); } private void JustAnExample ( ITaskContext context , VSProjectInfo vsProjectInfo ) { //// Do something. } Example will execute Pack task for each project in solution.","title":"Add tasks to target with a foreach loop"},{"location":"buildscript-fundamentals/#group-tasks-and-apply-when-onerror-finally-on-them","text":"Conditonal task execution with When clause on group of tasks. protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Example\" ) . AddCoreTask ( x => x . Build ()) . Group ( target => { target . AddCoreTask ( x => x . Pack ()); target . AddCoreTask ( x => x . NugetPush ( \"pathToPackage\" )); }, when : c => ! c . BuildSystems (). Jenkins (). IsRunningOnJenkins ); } Finally on group of tasks: onFinally acts just like finally in try/catch. context . CreateTarget ( \"Example\" ) . AddCoreTask ( x => x . Build ()) . Group ( target => { target . AddCoreTask ( x => x . Pack ()); target . AddCoreTask ( x => x . NugetPush ( \"pathToPackage\" )); }, onFinally : c => { c . Tasks (). DeleteFilesTask ( \"pathToNupkg\" , \"*.*\" , true ). Execute ( c ); }); OnError on group of tasks: You can perform some custom action when error occures in any of tasks that are in group. context . CreateTarget ( \"Example\" ) . AddCoreTask ( x => x . Build ()) . Group ( target => { target . AddCoreTask ( x => x . Pack ()); target . AddCoreTask ( x => x . NugetPush ( \"pathToPackage\" )); }, onError : ( c , error ) => { //// some custom action when error occures in any of the task in group. });","title":"Group tasks and apply When, OnError, Finally on them"},{"location":"buildscript-fundamentals/#asynchronus-or-parallel-execution-of-tasks-customcode-and-dependencies","text":"Tasks can be executed asynchrounously or in parallel with AddTaskAsync or AddCoreTaskAsync method. Custom code can be executed asynchrounosly with DoAsync method. Dependencies can be executed asynchrounosly with DependsOnAsync method. Following target executes 3 tasks in parallel. session . CreateTarget ( \"run.tests\" ) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName3\" )); Async and sync methods can also be mixed session . CreateTarget ( \"async.example\" ) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . AddTaskAsync ( x => x . NUnitTaskForNunitV3 ( \"TestProjectName1\" )) . Do ( SomeCustomMethod ) . DoAsync ( SomeCustomAsyncMethod2 ) . DoAsync ( SomeCustomAsyncMethod3 ); The code above will first execute 2 nunit tasks asynchronously and wait for both tasks to finish. Then it will execute SomeCustomMethod synchrounosly. After it is finished code from SomeCustomAsyncMethod2 and SomeCustomAsyncMethod3 will be executed in parallel.","title":"Asynchronus or parallel execution of tasks, customCode and dependencies"},{"location":"buildscript-fundamentals/#sequential-logging-in-asynchronus-executed-tasks-and-targets","text":"Usually logs are not readable when executing more than 1 task asynchronously or in parallel. That's why FlubuCore offers sequential logging in asynchronus tasks. You can enable them with .SequentialLogging(true) on target. It has to be placed before asynchronus tasks/target dependencies otherwise logs will not be sequential. context . CreateTarget ( \"Test\" ) . SetAsDefault () . SequentialLogging ( true ) . AddCoreTaskAsync ( x => x . Pack ()) . AddCoreTaskAsync ( x => x . Pack ()) . DependsOnAsync ( test2 , test3 ); Target executed in parallel with FlubuCore runner have sequential logging on by default. flubu target1 target2 --parallel","title":"sequential logging in asynchronus executed tasks and targets"},{"location":"buildscript-fundamentals/#other-features","text":"","title":"Other features"},{"location":"buildscript-fundamentals/#target-features","text":"SetAsDefault method: When applied to target that target is runned by default if no target is specified when running the script with runner. SetAsHidden method: When applied to target that target is not shown in help and it can only be run as other target dependency. Must method: Condition in must will have to be meet otherwise target execution will fail before any task get executed. Requires method: Parameter specified in required method must not be null otherwise target execution will fail before any task get executed.","title":"Target features"},{"location":"buildscript-fundamentals/#context-features","text":"Log: context.LogInfo(\"Some Text2\", ConsoleColor.Blue); GetVsSolution: Get's solution and it's projects information(such as full project path, target framework, runtimeidentifier..) context.GetVsSolution(); GetFiles: Get Files from specified directory with option to filter files with glob pattern context.GetFiles(OutputDirectory, \"*.nupkg\"); GetDirectories: Get Directories from specified directory with option to filter files with glob pattern context.GetFiles(OutputDirectory, \"*.nupkg\"); GetEnviromentVariable method: Get's the enviroment variable by name context.GetEnvironmentVariable(\"someVariable\");","title":"Context features"},{"location":"buildscript-fundamentals/#run-any-program-or-command-in-build-script-with-runprogramtask","text":"protected override void ConfigureTargets ( ITaskContext session ) { var runExternalProgramExample = session . CreateTarget ( \"run.libz\" ) . AddTask ( x => x . RunProgramTask ( @\"packages\\LibZ.Tool\\1.2.0\\tools\\libz.exe\" ) . WorkingFolder ( @\".\\src\" ) . WithArguments ( \"add\" ) . WithArguments ( \"--libz\" , \"Assemblies.libz\" )); } Linux Example: protected override void ConfigureTargets ( ITaskContext context ) { var runExternalProgramExample = context . CreateTarget ( \"systemctl.example\" ) AddTask ( x => x . RunProgramTask ( @\"systemctl\" ) . WithArguments ( \"start\" ) . WithArguments ( \"nginx.service\" )); }","title":"Run any program or command in build script with RunProgramTask"},{"location":"buildscript-fundamentals/#build-properties","text":"You can define various build properties with Attributes on properties or in ConfigureBuildProperties method (old way) to share them in different tasks and custom code. Following example shows how to share solution file name and configuration across various targets/tasks. [SolutionFileName] public string SolutionFileName { get ; set ; } = \"FlubuExample.sln\" ; [BuildConfiguration] public string BuildConfiguration { get ; set ; } = \"Release\" ; protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"build\" ) . AddCoreTask ( x => x . Build ()); context . CreateTarget ( \"pack\" ) . AddCoreTask ( x => x . Pack ()); } Alternative: [BuildProperty(BuildProps.BuildConfiguration)] public string BuildConfiguration { get ; set ; } = \"Release\" ; If Solution file name and path would not be set through build property attributes you would have to set it in each task separately. like so: protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"build\" ) . AddCoreTask ( x => x . Build () . Project ( \"FlubuExample.sln\" ) . Configuration ( \"Release\" )); context . CreateTarget ( \"pack\" ) . AddCoreTask ( x => x . Pack () . Project ( \"FlubuExample.sln\" ) . Configuration ( \"Release\" )); }","title":"Build properties"},{"location":"buildscript-fundamentals/#predefined-build-properties","text":"Some build properties are already defined. You can access them through interface: context.Properties.Get(PredefinedBuildProperties.OsPlatform); Available predefined build properties: OsPlatform PathToDotnetExecutable UserProfileFolder OutputDir ProductRootDir All of them can be overriden.","title":"Predefined build properties"},{"location":"buildscript-fundamentals/#pass-command-line-arguments-settings-from-json-configuration-file-or-environment-variables-to-your-build-script-properties","text":"You can pass command line arguments, settings from json configuration file or environment variables to your build script properties by adding FromArg attribute to property. public class SimpleScript : DefaultBuildScript { [FromArg(\"sn\", \"If true app is deployed on second node. Otherwise not.\")] public bool deployOnSecondNode { get ; set ; } protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Deploy.Exapmle\" ) . AddTask ( x => x . FlubuWebApiTasks (). GetTokenTask ( \"user\" , \"pass\" ). SetWebApiBaseUrl ( \"noade1Url\" )) . AddTask ( x => x . FlubuWebApiTasks (). UploadPackageTask ( \"packageDir\" , \"*.zip\" )) . AddTask ( x => x . FlubuWebApiTasks (). ExecuteScriptTask ( \"Deploy\" , \"DeployScript.cs\" )) . Group ( target => { target . AddTask ( x => x . FlubuWebApiTasks (). GetTokenTask ( \"user\" , \"pass\" ). SetWebApiBaseUrl ( \"noade2Url\" )) . AddTask ( x => x . FlubuWebApiTasks (). UploadPackageTask ( \"packageDir\" , \"*.zip\" )) . AddTask ( x => x . FlubuWebApiTasks (). ExecuteScriptTask ( \"Deploy\" , \"DeployScript.cs\" )); }, when : c => deployOnSecondNode ); } } First parameter in FromArg attribute is the argument key. Second is the help description of the property shown in flubu runner. You actually don't need to put attribute on property. If u dont then the key is the same as property name and help is not shown for property in build script runner. Property types that are supported: string, boolean, int, long, decimal, double, DateTime.","title":"Pass command line arguments, settings from json configuration file or environment variables to your build script properties."},{"location":"buildscript-fundamentals/#passing-command-line-argument-to-build-script-property","text":"Dotnet flubu Deploy.Example -sn=true","title":"Passing command line argument to build script property."},{"location":"buildscript-fundamentals/#passing-setting-from-json-configuration-file-to-build-script-property","text":"Create file FlubuSettings.json where Flubu runner is located. Add argument key and value to file in json format. For above example json file would look like this: { \"sn\" : true , \"SomeOtherKey\" : \"SomeOtherValue\" } It's typical to have different configuration settings for different environments for example development, testing, and production. Just create different json files FlubuSettings.{Environment}.Json and set enviroment variable 'ASPNETCORE_ENVIRONMENT' on desired machine You can also create json configuration file by machine name FlubuSettings.{MachineName}.Json . If MachineName in file matches the machine name Flubu will automatically read settings from that file.","title":"Passing setting from json configuration file to build script property"},{"location":"buildscript-fundamentals/#passing-enviroment-variable-to-build-script-property","text":"You can also set script arguments through environment variables. environment variables must have prefix flubu_ For above example you would add environment variable from windows command line with the following command: set flubu_sn=true","title":"Passing enviroment variable to build script property"},{"location":"buildscript-fundamentals/#pass-console-arguments-settings-from-json-configuration-file-environment-variables-with-formember-to-tasks","text":"There is an alternative more sophisticated way to pass console arguments, settings and environment variables to tasks protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"compile\" ) . AddTask ( x => x . CompileSolutionTask () . ForMember ( y => y . SolutionFileName ( \"someSolution.sln\" ), \"solution\" , \"The solution to build.\" )); } First parameter is the method or property argument that will be passed through. values set in method parameters are default values if argument is not specified when running the build script. Second parameter is the argument key. Third optional parameter is help that will be displayed in detailed target help. If parameter is not set then default generated help will be displayed. Dotnet flubu compile -solution=someothersolution.sln","title":"Pass console arguments, settings from json configuration file, environment variables with ForMember to tasks."},{"location":"buildscript-fundamentals/#build-system-providers","text":"You can acces various build, commit... information for various build systems (such as Jenkins, TeamCity, AppVeyor, Travis...) protected override void ConfigureTargets ( ITaskContext context ) { bool isLocalBuild = context . BuildSystems (). IsLocalBuild ; var gitCommitId = context . BuildSystems (). Jenkins (). GitCommitId ; }","title":"Build system providers"},{"location":"buildscript-fundamentals/#build-events","text":"OnBuildFailed event: public class BuildScript : DefaultBuildScript { protected override void OnBuildFailed ( ITaskSession session , Exception ex ) { } } before and after target execution events: protected override void BeforeTargetExecution ( ITaskContext context ) { } protected override void AfterTargetExecution ( ITaskContext context ) { } before and after build execution events: protected override void BeforeBuildExecution ( ITaskContext context ) { } protected override void AfterBuildExecution ( ITaskSession session ) { }","title":"Build events"},{"location":"buildscript-fundamentals/#partial-and-base-class-in-script","text":"Partial and base classes are loaded automatically if they are located in the same directory as buildscript. Otherwise they have to be added with Include attribute .","title":"Partial and base class in script"},{"location":"execute-script-in-console-app-or-pack-as-global-tool/","text":"To execute a acript in console application add the following code to Program.cs : public class Program { public static void Main ( string [] args ) { var engine = new FlubuEngine (); engine . RunScript < MyScript >( args ); } } After that you can create a global tool from your console application and share your script with other developers through global tool. How to create a global tool If you want to execute script directly in a console application it is also recomended to add .flubu file to the root of your repository because when you execute script through console application working folder of the script will be /bin/{BuildConfiguration} and some target's might fail of that because working folder is not correct. When FlubuCore starts to run a build script, it searches .flubu file automatically, and it keeps searching it all the way up through parent directories until that file is found or reached the root directory of current drive. The location where a .flubu file is found will be used as the \"work directory\" during a build process, and a correct \"work directory\" is crucial for us to use relative path in our build scripts. FlubuCore command line tool has an option to help you create .flubu file, simply type flubu setup and answer questions.","title":"Execute script in console app or pack as global tool"},{"location":"flubu-modules/","text":"It is possible to change FlubuCore internal logic by replacing FlubuCore modules through DI. For example logging, target runner, task context etc.. could be changed. public class BuildScript : DefaultBuildScript { public override void ConfigureServices ( IServiceCollection services ) { services . Replace < IFlubuSession , MyFlubuSession >(); } public override void Configure ( ILoggerFactory loggerFactory ) { loggerFactory . AddProvider ( new MyLoggerProvider ()); } }","title":"FlubuCore modules"},{"location":"flubu-templates/","text":"Installing built-in templates \u00b6 With FlubuCore templates it is possible to create new build or deploy scripts in no time. All you have to do is: Install FlubuCore global tool dotnet tool install --global FlubuCore.Tool Install template with flubu new <TemplateName> Available templates names: empty , lib Interactive mode will guide you through how to install the template. With flubu new command all available templates are listed. Creating and installing custom templates. \u00b6 It is also possible to create custom templates on github or gitlab servers with just few steps. Add files to the repository that your template should contain such as your Flubu build script file, Flubu project file etc. Anything that is needed in your build project can be added to template. Sample of template repository can be found at default template. This template can be installed with flubu new empty and library template. This template can be installed with flubu new lib Each template can also contain template configuration file. Configuration file can be in json(Template.json) format or in cs (Template.cs) format. Custom template can be installed with command flubu new -u={RepositoryUrl} for example flubu new -u=https://github.com/flubu-core/FlubuCore.DefaultTemplate Advantages of configuration file in json format: Abit faster installation of template as cs file needs to be compiled first Some prefere configuration in json over fluent interface Probably more suitable for simple templates Advanatages of configuration file in cs format: Intelisene with code completion and help. It is possible to add custom code to template for custom template processing when installing the template. Configuration file options \u00b6 ReplacementTokens \u00b6 Each file in template can contain replacement tokens. Replacement tokens will be replaced in interactive mode when installing the template. Replacement tokens must be defined in configuration file. Sample of Template.json with one replacement token: { \"Tokens\" : [ { \"Token\" : \"{{SolutionFileName}}\" , // Token to be replaced in template files. \"Description\" : \"Enter relative path to solution filename:\" , // Input text shown in interactive mode when entering value for replacement token. \"Help\" : null , // Help shown at the bottom of console in the interactive mode. \"DefaultValue\" : null , // Default value shown as hint in the beginning in interactive mode. \"InputType\" : Files , // Input type of the replacement token. See documentation bellow for available input types. \"Values\" : null , // Available values in interactive mode for input type Hint or Options. \"Files\" : { // Options for 'Files' InputType. \"AllowedFileExtension\" : \"sln\" // Allowed file extension to be entered in interactive mode. } } ] } Let's say we have following BuildScript.cs file in our template repository which contais {{SolutionFileName}} replacement token public class BuildScript : DefaultBuildScript { [SolutionFileName] public string SolutionFileName { get ; set ; } = \"{{SolutionFileName}}\" ; [BuildConfiguration] public string BuildConfiguration { get ; set ; } = \"Release\" ; protected override void ConfigureTargets ( ITaskContext context ) { var compile = context . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the solution.\" ) . AddCoreTask ( x => x . Build ()); } } When installing the template {{SolutionFileName}} replacement token will be replaced with entered value in interactive mode. Same as above sample of template configuration json file can be done in template.cs configuration file public class Template : IFlubuTemplate { public void ConfigureTemplate ( IFlubuTemplateBuilder templateBuilder ) { templateBuilder . AddReplacementToken ( new TemplateReplacementToken () { Token = \"{{SolutionFileName}}\" , Description = \"Enter relative path to solution filename:\" , InputType = InputType . Files , Files = new FilesInputType { AllowedFileExtension = \"sln\" }, Help = null , DefaultValue = null , Values = null , }); } } Available input types \u00b6 Text : Regular text can be entered for the replacement token Files : Files can be entered for the replacement token. Hints for directories and files with tab completion are available Hints : With InputType Hints property: Values must be defined. All values are shown as hints with tab completion in interactive mode. Options : With InputType Options property: Values must be defined. All values are shown as options that can be choosen. Custom template processing when installing template with custom code in template.cs configuration file \u00b6 Add IFlubuTemplateTask interface to your Template.cs configuration file. This will add 4 methods where your custom template processing will occur. Below is a dummy sample that will print some text to the console when installation of the template will start and end. public class Template : IFlubuTemplate , IFlubuTemplateTask { public void ConfigureTemplate ( IFlubuTemplateBuilder templateBuilder ) { templateBuilder . AddReplacementToken ( new TemplateReplacementToken () { Token = \"{{SolutionFileName}}\" , Description = \"Enter relative path to solution filename:\" , InputType = InputType . Files , Files = new FilesInputType { AllowedFileExtension = \"sln\" }, Help = null , DefaultValue = null , Values = null , }); } public void BeforeFileProcessing ( TemplateModel template , List < string > files ) { Console . WriteLine ( \"Started installing awesome custom template\" ); } public void BeforeFileCopy ( string sourceFilePath ) { } public void AfterFileCopy ( string destinationFilePath ) { } public void AfterFileProcessing ( TemplateModel template ) { Console . WriteLine ( \"Finished installing awesome custom template\" ); } } BeforeFileProcessing occures right after the template was downloded from git repository. BeforeFileCopy occures before individual file is copied from the downloaded location to the destination path (where flubu new command was exectued). Replacement tokens are replaced before files are copied AfterFileCopy occures after individual file is copied from the downloaded location to the destination path. AfterFileProcessing occures when all files are copied to the destination path","title":"FlubuCore templates"},{"location":"flubu-templates/#installing-built-in-templates","text":"With FlubuCore templates it is possible to create new build or deploy scripts in no time. All you have to do is: Install FlubuCore global tool dotnet tool install --global FlubuCore.Tool Install template with flubu new <TemplateName> Available templates names: empty , lib Interactive mode will guide you through how to install the template. With flubu new command all available templates are listed.","title":"Installing built-in templates"},{"location":"flubu-templates/#creating-and-installing-custom-templates","text":"It is also possible to create custom templates on github or gitlab servers with just few steps. Add files to the repository that your template should contain such as your Flubu build script file, Flubu project file etc. Anything that is needed in your build project can be added to template. Sample of template repository can be found at default template. This template can be installed with flubu new empty and library template. This template can be installed with flubu new lib Each template can also contain template configuration file. Configuration file can be in json(Template.json) format or in cs (Template.cs) format. Custom template can be installed with command flubu new -u={RepositoryUrl} for example flubu new -u=https://github.com/flubu-core/FlubuCore.DefaultTemplate Advantages of configuration file in json format: Abit faster installation of template as cs file needs to be compiled first Some prefere configuration in json over fluent interface Probably more suitable for simple templates Advanatages of configuration file in cs format: Intelisene with code completion and help. It is possible to add custom code to template for custom template processing when installing the template.","title":"Creating and installing custom templates."},{"location":"flubu-templates/#configuration-file-options","text":"","title":"Configuration file options"},{"location":"flubu-templates/#replacementtokens","text":"Each file in template can contain replacement tokens. Replacement tokens will be replaced in interactive mode when installing the template. Replacement tokens must be defined in configuration file. Sample of Template.json with one replacement token: { \"Tokens\" : [ { \"Token\" : \"{{SolutionFileName}}\" , // Token to be replaced in template files. \"Description\" : \"Enter relative path to solution filename:\" , // Input text shown in interactive mode when entering value for replacement token. \"Help\" : null , // Help shown at the bottom of console in the interactive mode. \"DefaultValue\" : null , // Default value shown as hint in the beginning in interactive mode. \"InputType\" : Files , // Input type of the replacement token. See documentation bellow for available input types. \"Values\" : null , // Available values in interactive mode for input type Hint or Options. \"Files\" : { // Options for 'Files' InputType. \"AllowedFileExtension\" : \"sln\" // Allowed file extension to be entered in interactive mode. } } ] } Let's say we have following BuildScript.cs file in our template repository which contais {{SolutionFileName}} replacement token public class BuildScript : DefaultBuildScript { [SolutionFileName] public string SolutionFileName { get ; set ; } = \"{{SolutionFileName}}\" ; [BuildConfiguration] public string BuildConfiguration { get ; set ; } = \"Release\" ; protected override void ConfigureTargets ( ITaskContext context ) { var compile = context . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the solution.\" ) . AddCoreTask ( x => x . Build ()); } } When installing the template {{SolutionFileName}} replacement token will be replaced with entered value in interactive mode. Same as above sample of template configuration json file can be done in template.cs configuration file public class Template : IFlubuTemplate { public void ConfigureTemplate ( IFlubuTemplateBuilder templateBuilder ) { templateBuilder . AddReplacementToken ( new TemplateReplacementToken () { Token = \"{{SolutionFileName}}\" , Description = \"Enter relative path to solution filename:\" , InputType = InputType . Files , Files = new FilesInputType { AllowedFileExtension = \"sln\" }, Help = null , DefaultValue = null , Values = null , }); } }","title":"ReplacementTokens"},{"location":"flubu-templates/#available-input-types","text":"Text : Regular text can be entered for the replacement token Files : Files can be entered for the replacement token. Hints for directories and files with tab completion are available Hints : With InputType Hints property: Values must be defined. All values are shown as hints with tab completion in interactive mode. Options : With InputType Options property: Values must be defined. All values are shown as options that can be choosen.","title":"Available input types"},{"location":"flubu-templates/#custom-template-processing-when-installing-template-with-custom-code-in-templatecs-configuration-file","text":"Add IFlubuTemplateTask interface to your Template.cs configuration file. This will add 4 methods where your custom template processing will occur. Below is a dummy sample that will print some text to the console when installation of the template will start and end. public class Template : IFlubuTemplate , IFlubuTemplateTask { public void ConfigureTemplate ( IFlubuTemplateBuilder templateBuilder ) { templateBuilder . AddReplacementToken ( new TemplateReplacementToken () { Token = \"{{SolutionFileName}}\" , Description = \"Enter relative path to solution filename:\" , InputType = InputType . Files , Files = new FilesInputType { AllowedFileExtension = \"sln\" }, Help = null , DefaultValue = null , Values = null , }); } public void BeforeFileProcessing ( TemplateModel template , List < string > files ) { Console . WriteLine ( \"Started installing awesome custom template\" ); } public void BeforeFileCopy ( string sourceFilePath ) { } public void AfterFileCopy ( string destinationFilePath ) { } public void AfterFileProcessing ( TemplateModel template ) { Console . WriteLine ( \"Finished installing awesome custom template\" ); } } BeforeFileProcessing occures right after the template was downloded from git repository. BeforeFileCopy occures before individual file is copied from the downloaded location to the destination path (where flubu new command was exectued). Replacement tokens are replaced before files are copied AfterFileCopy occures after individual file is copied from the downloaded location to the destination path. AfterFileProcessing occures when all files are copied to the destination path","title":"Custom template processing when installing template with custom code in template.cs configuration file"},{"location":"getting-started/","text":"Getting started with FlubuCore \u00b6 Getting started .NET core \u00b6 Installation .NET core \u00b6 Add new project to solution e.g. BuildScript Add FlubuCore reference to project with NuGet Or Install with FlubuCore template \u00b6 In console navigate where your solution is located. Run dotnet new -i FlubuCore.Template Run dotnet new FlubuCore This will add BuildScript.csproj with FlubuCore references and FlubuCore script template Write and run your first build script in .NET core \u00b6 Add BuildScript.cs file to buildscript projetct and add following code. Following code adds compile target to flubu commands. Compile target compiles the solution. public class MyBuildScript : DefaultBuildScript { protected override void ConfigureTargets ( ITaskContext context ) { var compile = context . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the solution.\" ) . AddCoreTask ( x => x . Build ( \"FlubuExample.sln\" )); } } Run build script in .NET core with dotnet CLI tool \u00b6 Add dotnet-flubu as Dotnet tool to csproj or xproj(project.json). No need if u installed FlubuCore with template csproj: <ItemGroup> <DotNetCliToolReference Include= \"dotnet-flubu\" Version= \"1.7.0\" /> </ItemGroup> project.json: \"tools\" : { \"dotnet-flubu\" : { \"version\" : \"1.7.0\" } } Run dotnet restore . This command will restore dotnet-flubu package and add it to dotnet tool commands. Run dotnet flubu help . There you will see besided default commands the compile command that we just added. Run dotnet flubu compile This command will compile your solution. Run build script in .NET core with local or global tool \u00b6 .net core sdk 2.1.300 or greater must be installed. Install FlubuCore local or global tool: dotnet tool install --global FlubuCore.Tool Run flubu compile where build script is located. It will compile your solution. This is very basic build script just for you to see how simple it is to get you started. FlubuCore has to offer a lot of nice features. Read more about them at Build script fundamentals . You should also take a look at .net core examples they will give you hints how to write your build script and see most of the main flubu features in action. Getting started .NET \u00b6 Requirements .NET \u00b6 Build script project where FlubuCore is referenced must target .NET framework 4.62 or greater. If this is not possible you can use Flubu version 2.64 or less which only requires .NET Framework 4.0. To run build script with FlubuCore runner .net runtime 4.0 or greater is required. Installation .NET \u00b6 Add new project to solution e.g. BuildScript Add FlubuCore.Runner reference to project with nuGet. This will add reference To FlubuCore.dll, add BuildScript.cs (build script template) to project and it will also add flubu.exe for running the buildscript. Write and run your first build script in .NET \u00b6 Modify BuildScript.cs with the following code. Change solution name to yours. Following code adds compile target to flubu commands. Compile target compiles the solution. using FlubuCore.Context ; using FlubuCore.Scripting ; public class BuildScript : DefaultBuildScript { protected override void ConfigureTargets ( ITaskContext session ) { var compile = session . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the solution.\" ) . AddTask ( x => x . CompileSolutionTask ()); } } Run build script \u00b6 Open cmd and navigate to buildscript project directory. Run flubu.exe help. There you will see besides default commands the compile command that we just added. Run flubu.exe compile. It will compile your solution. This is very basic build script just for you to see how simple it is to get you started. FlubuCore has to offer a lot of nice features. Read more about them at Build script fundamentals . You should also take a look at .net examples they will give you hints how to write your build script and see most of the main flubu features in action.","title":"Getting started"},{"location":"getting-started/#getting-started-with-flubucore","text":"","title":"Getting started with FlubuCore"},{"location":"getting-started/#getting-started-net-core","text":"","title":"Getting started .NET core"},{"location":"getting-started/#installation-net-core","text":"Add new project to solution e.g. BuildScript Add FlubuCore reference to project with NuGet","title":"Installation .NET core"},{"location":"getting-started/#or-install-with-flubucore-template","text":"In console navigate where your solution is located. Run dotnet new -i FlubuCore.Template Run dotnet new FlubuCore This will add BuildScript.csproj with FlubuCore references and FlubuCore script template","title":"Or Install with FlubuCore template"},{"location":"getting-started/#write-and-run-your-first-build-script-in-net-core","text":"Add BuildScript.cs file to buildscript projetct and add following code. Following code adds compile target to flubu commands. Compile target compiles the solution. public class MyBuildScript : DefaultBuildScript { protected override void ConfigureTargets ( ITaskContext context ) { var compile = context . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the solution.\" ) . AddCoreTask ( x => x . Build ( \"FlubuExample.sln\" )); } }","title":"Write and run your first build script in .NET core"},{"location":"getting-started/#run-build-script-in-net-core-with-dotnet-cli-tool","text":"Add dotnet-flubu as Dotnet tool to csproj or xproj(project.json). No need if u installed FlubuCore with template csproj: <ItemGroup> <DotNetCliToolReference Include= \"dotnet-flubu\" Version= \"1.7.0\" /> </ItemGroup> project.json: \"tools\" : { \"dotnet-flubu\" : { \"version\" : \"1.7.0\" } } Run dotnet restore . This command will restore dotnet-flubu package and add it to dotnet tool commands. Run dotnet flubu help . There you will see besided default commands the compile command that we just added. Run dotnet flubu compile This command will compile your solution.","title":"Run build script in .NET core with dotnet CLI tool"},{"location":"getting-started/#run-build-script-in-net-core-with-local-or-global-tool","text":".net core sdk 2.1.300 or greater must be installed. Install FlubuCore local or global tool: dotnet tool install --global FlubuCore.Tool Run flubu compile where build script is located. It will compile your solution. This is very basic build script just for you to see how simple it is to get you started. FlubuCore has to offer a lot of nice features. Read more about them at Build script fundamentals . You should also take a look at .net core examples they will give you hints how to write your build script and see most of the main flubu features in action.","title":"Run build script in .NET core with local or global tool"},{"location":"getting-started/#getting-started-net","text":"","title":"Getting started .NET"},{"location":"getting-started/#requirements-net","text":"Build script project where FlubuCore is referenced must target .NET framework 4.62 or greater. If this is not possible you can use Flubu version 2.64 or less which only requires .NET Framework 4.0. To run build script with FlubuCore runner .net runtime 4.0 or greater is required.","title":"Requirements .NET"},{"location":"getting-started/#installation-net","text":"Add new project to solution e.g. BuildScript Add FlubuCore.Runner reference to project with nuGet. This will add reference To FlubuCore.dll, add BuildScript.cs (build script template) to project and it will also add flubu.exe for running the buildscript.","title":"Installation .NET"},{"location":"getting-started/#write-and-run-your-first-build-script-in-net","text":"Modify BuildScript.cs with the following code. Change solution name to yours. Following code adds compile target to flubu commands. Compile target compiles the solution. using FlubuCore.Context ; using FlubuCore.Scripting ; public class BuildScript : DefaultBuildScript { protected override void ConfigureTargets ( ITaskContext session ) { var compile = session . CreateTarget ( \"compile\" ) . SetDescription ( \"Compiles the solution.\" ) . AddTask ( x => x . CompileSolutionTask ()); } }","title":"Write and run your first build script in .NET"},{"location":"getting-started/#run-build-script","text":"Open cmd and navigate to buildscript project directory. Run flubu.exe help. There you will see besides default commands the compile command that we just added. Run flubu.exe compile. It will compile your solution. This is very basic build script just for you to see how simple it is to get you started. FlubuCore has to offer a lot of nice features. Read more about them at Build script fundamentals . You should also take a look at .net examples they will give you hints how to write your build script and see most of the main flubu features in action.","title":"Run build script"},{"location":"override-add-options/","text":"FlubuCore offers you to add or override options in all tasks that run external processes. Let's say you have target context . CreateTarget ( \"Example\" ) ` . AddCoreTask ( x => x . Build ( \"MySolution.sln\" ). Configuration ( \"Release\" ); and you wan't to build solution in debug configuration. You could just write in console flubu example --configuration=Debug flubu would execute dotnet build MySolution.sln --configuration Debug Note option keys are the same as in external processes. short versions of options keys also work. So in above example -c=debug would also work. FlubuCore also support tab completion for all options in tasks that run's external processes in Interactive mode Tasks in FlubuCore plugins that does not support overriding of options out of the box can still be overriden with special prefix before option key /o: /o:{external_process_option={value} With /o: FlubuCore adds specified option to all tasks in target's which can be a problem if target execute multiple tasks. So instead of /o: you can use prefix by task name /{taskName}:{external_process_option}={value} Alternatively you can change default prefix on task context . CreateTarget ( \"Publish\" ) AddCoreTask ( x => x . Publish () . ChangeDefaultAdditionalOptionPrefix ( \"/p:\" )); Example \u00b6 Build task does support overriding of options out of the box but for the simplicity of the example build task is used. context . CreateTarget ( \"Example\" ) ` . AddCoreTask ( x => x . Build ( \"MySolution.sln\" ). Configuration ( \"Release\" ); and you wan't to build solution in debug configuration. You could just write in console flubu example /o:configuration=Debug or flubu example /o:c=Debug or flubu example /build:c=Debug flubu would execute dotnet build MySolution.sln -c Debug","title":"Override existing options or add additional options to tasks through console"},{"location":"override-add-options/#example","text":"Build task does support overriding of options out of the box but for the simplicity of the example build task is used. context . CreateTarget ( \"Example\" ) ` . AddCoreTask ( x => x . Build ( \"MySolution.sln\" ). Configuration ( \"Release\" ); and you wan't to build solution in debug configuration. You could just write in console flubu example /o:configuration=Debug or flubu example /o:c=Debug or flubu example /build:c=Debug flubu would execute dotnet build MySolution.sln -c Debug","title":"Example"},{"location":"referencing-external-assemblies/","text":"Referencing external assemblies in build script \u00b6 FlubuCore loads all assemblies references and nuget packages automatically from build script csproj. Csproj must be at on of the location specified here If not assembly and nuget references will not be loaded automatically when executing script. Note You can also disable referencing assemblies and nuget packages from build script by adding attribute to build script. [DisableLoadScriptReferencesAutomatically] public class BuildScript : DefaultBuildScript { } Alternatively when you are running scripts without csproj(for example deploy scripts) external references can be added with directives in three ways: By assembly relative or full path \u00b6 On the build script class you have to add attribute: [Assembly(@\".\\packages\\Newtonsoft.Json.9.0.1\\lib\\net45\\Newtonsoft.Json.dll\")] public class BuildScript : DefaultBuildScript { public void ReferencedAssemlby ( ITaskContext context ) { JsonConvert . SerializeObject ( \"Example\" ); } } FlubuCore can also load all assemblies from specified directory and optionaly from it's subdirectories [AssemblyFromDirectory(@\".\\Packages\", true)] public class BuildScript : DefaultBuildScript { } Referencing nuget packages \u00b6 Flubu supports referencing nuget packages. .net core sdk or msbuild must be installed if u want to reference nuget packages otherwise they will not get restored. You have to add NugetPackage attribute on the script class: [NugetPackage(\"Newtonsoftjson\", \"11.0.2\")] public class BuildScript : DefaultBuildScript { public void ReferencedNugetPackage ( ITaskContext context ) { JsonConvert . SerializeObject ( \"Example\" ); } } Load assembly by assembly full name \u00b6 System assemblies can be loaded by fully qualifed assemlby name. You have to add Reference attribute on the script class: [Reference(\"System.Xml.XmlDocument, System.Xml, Version=4.0.0.0, Culture=neutral, publicKeyToken=b77a5c561934e089\")] public class BuildScript : DefaultBuildScript { public void ReferencedAssemlby ( ITaskContext context ) { XmlDocument xml = new XmlDocument (); } } One way to get fully qualifed assembly name: 1 var fullQualifedAssemblyName = typeof(XmlDocument).Assembly.FullName; Load all assemblies from directory \u00b6 Even if you are not using your script together with csproj flubu can load all external assemblies for you automatically from directory (assemblies in subdirectories are also loaded ). By default flubu loads all assemblies from directory FlubuLib. Just create the directory at the flubu runner location and put assemblies in that directory. You can specify directory in flubu runner from where to load assemblyes also: flubu.exe -ass=somedirectory dotnet flubu -ass=somedirectory alternatively you can put ass key into flubusettings.json file: 1 2 3 4 { \"ass\" : \"someDirectory\", \"SomeOtherKey\" : \"SomeOtherValue\" }` Adding other .cs files to script \u00b6 Other .cs files have to be added through attribute they are not automatically loaded from buildscript project file. Exception are build script base classes and partial classes they are loaded automatically. [Include(@\".\\BuildHelper.cs\")] public class BuildScript : DefaultBuildScript { public void Example ( ITaskContext context ) { BuildHelper . SomeMethod (); } } FlubuCore can also load all .cs files to script from specified directory and optionaly from it's subfolders. [IncludeFromDirectory(@\".\\Helpers\", true)] public class BuildScript : DefaultBuildScript { }","title":"Referencing external assemblies in build script"},{"location":"referencing-external-assemblies/#referencing-external-assemblies-in-build-script","text":"FlubuCore loads all assemblies references and nuget packages automatically from build script csproj. Csproj must be at on of the location specified here If not assembly and nuget references will not be loaded automatically when executing script. Note You can also disable referencing assemblies and nuget packages from build script by adding attribute to build script. [DisableLoadScriptReferencesAutomatically] public class BuildScript : DefaultBuildScript { } Alternatively when you are running scripts without csproj(for example deploy scripts) external references can be added with directives in three ways:","title":"Referencing external assemblies in build script"},{"location":"referencing-external-assemblies/#by-assembly-relative-or-full-path","text":"On the build script class you have to add attribute: [Assembly(@\".\\packages\\Newtonsoft.Json.9.0.1\\lib\\net45\\Newtonsoft.Json.dll\")] public class BuildScript : DefaultBuildScript { public void ReferencedAssemlby ( ITaskContext context ) { JsonConvert . SerializeObject ( \"Example\" ); } } FlubuCore can also load all assemblies from specified directory and optionaly from it's subdirectories [AssemblyFromDirectory(@\".\\Packages\", true)] public class BuildScript : DefaultBuildScript { }","title":"By assembly relative or full path"},{"location":"referencing-external-assemblies/#referencing-nuget-packages","text":"Flubu supports referencing nuget packages. .net core sdk or msbuild must be installed if u want to reference nuget packages otherwise they will not get restored. You have to add NugetPackage attribute on the script class: [NugetPackage(\"Newtonsoftjson\", \"11.0.2\")] public class BuildScript : DefaultBuildScript { public void ReferencedNugetPackage ( ITaskContext context ) { JsonConvert . SerializeObject ( \"Example\" ); } }","title":"Referencing nuget packages"},{"location":"referencing-external-assemblies/#load-assembly-by-assembly-full-name","text":"System assemblies can be loaded by fully qualifed assemlby name. You have to add Reference attribute on the script class: [Reference(\"System.Xml.XmlDocument, System.Xml, Version=4.0.0.0, Culture=neutral, publicKeyToken=b77a5c561934e089\")] public class BuildScript : DefaultBuildScript { public void ReferencedAssemlby ( ITaskContext context ) { XmlDocument xml = new XmlDocument (); } } One way to get fully qualifed assembly name: 1 var fullQualifedAssemblyName = typeof(XmlDocument).Assembly.FullName;","title":"Load assembly by assembly full name"},{"location":"referencing-external-assemblies/#load-all-assemblies-from-directory","text":"Even if you are not using your script together with csproj flubu can load all external assemblies for you automatically from directory (assemblies in subdirectories are also loaded ). By default flubu loads all assemblies from directory FlubuLib. Just create the directory at the flubu runner location and put assemblies in that directory. You can specify directory in flubu runner from where to load assemblyes also: flubu.exe -ass=somedirectory dotnet flubu -ass=somedirectory alternatively you can put ass key into flubusettings.json file: 1 2 3 4 { \"ass\" : \"someDirectory\", \"SomeOtherKey\" : \"SomeOtherValue\" }`","title":"Load all assemblies from directory"},{"location":"referencing-external-assemblies/#adding-other-cs-files-to-script","text":"Other .cs files have to be added through attribute they are not automatically loaded from buildscript project file. Exception are build script base classes and partial classes they are loaded automatically. [Include(@\".\\BuildHelper.cs\")] public class BuildScript : DefaultBuildScript { public void Example ( ITaskContext context ) { BuildHelper . SomeMethod (); } } FlubuCore can also load all .cs files to script from specified directory and optionaly from it's subfolders. [IncludeFromDirectory(@\".\\Helpers\", true)] public class BuildScript : DefaultBuildScript { }","title":"Adding other .cs files to script"},{"location":"tasks/","text":"Here you can find list of FlubuCore built in tasks with short description. Each task have fluent interface. See code documentation for detailed task documentation. If u have any questions about a task join us on gitter. Tasks \u00b6 Task name Description RunProgramTask Task runs specified external program CompileSolutionTask Task compiles specified solution. PackageTask Task Packages specified directories and files into specified directory or zip file.. FetchBuildVersionFromFileTask Task fetches build version from file. GitVersionTask GitVersion is a tool to help you achieve Semantic Versioning on your project. [[ Documentation FetchVersionFromExternalSourceTask Task fetches build version from external source(Appveyor, travis, jenkins...). GenerateCommonAssemlbyInfoTask Task generates common assembly info for solution NUnitTask Task runs nunit tests with nunit.exe runner XunitTask Task runs xunit tests with xunit.exe runner NUnitWithDotCoverTaskTask runs nunit tests in combination with dotCover test coverage analysis PublishNugetPackageTask Task publishes nuget package to specified nuget server NugetCmdLineTask Manipulate nugets with nuget.exe UpdateXmlFileTask Updates an XML file using the specified update commands. UpdateJsonFileTask Task updates an JSON file using the specified update commands. CleanoutputTask Task clean all projects outputs in solution. ControlServiceTask Control windows service with sc.exe command. CreateWindowsServiceTask Creates windows service with sc.exe command. ExecutePowerShellScriptTask Executes specified power shell script. SqlCmdTask Execute SQL script files with sqlcmd.exe CreateAppPoolTask Task creates new application pool in iis. ControlAppPoolTask Task can start/stop application pool. DeleteAppPoolTask Task deletes specified application pool. CreateWebApplicationTask Task creates new web application for specified web site in iis. CreateWebSiteTask Task creates new web site in iis. AddWebSiteBindingTask Task compiles specified solution. GetLocalIisVersionTask Task gets the version on iis on local machine. ReplaceTokenTask Task Replaces specified tokens in file. ReplaceTextTask Task Replaces specified texts in file. CopyDirectoryStructureTask Task copies files from one directory to another with specified filters. CopyFileTask Task copies file from from one directory to another. CopyDirectoryStructureTask Copies a directory tree from the source to the destination.. CreateDirectoryTask Task creates directory at specified location. DeleteDirectoryTask Task deletes specified directory. DeleteFilesTask Task delete files from specified directory matching specified pattern. UnzipFileTask Task unzips specified zip file to specified location. ZipFileTask Task zips specified files. OpenCoverTask Task runs open cover tool. OpenCoverToCoberturaTask Task runs open cover to cobertuta tool. CoverageReportTask Task runs the coverage report generator tool. LoadSolutionTask Task load's solution information to the flubu session. T4TemplateTask Generate T4 template with TextTransform.exe utility.. GitTasks Git Clone, Add, Commit, Pull, Push, Tag, RemoveFiles tasks. DockerTasks Build, Run, Stop Remove Container, Remove Image and all other tasks for coresponding docker cli commands. All tasks are genereated from offical docker documentation. FlubuWebApiTasks Various flubu web api client tasks. .net core Tasks \u00b6 Task name Description ExecuteDotnetTask Executes specified dotnet command. DotnetRestoreTask Restores the dependencies and tools for a given application / project.. DotnetPublishTask compiles the application, reads through its dependencies specified in the project file and publishes the resulting set of files to a directory. DotnetBuildTask Builds a project and all of its dependencies. DotnetPackTask command builds the project and creates NuGet packages. The result of this command is a NuGet package. DotnetNugetPushTask Pushes the nuget package to the nuget server. DotnetTestTask Runs tests using a test runner specified in the project.json / csproj. DotnetCleanTask Cleans the output of a project. DotnetToolTask All dotnet tool commands. DotnetEfTasks Various entity framework tasks. UpdateNetCoreVersionTask Updates the version in csproj / project.json file CoverletTask Coverlet is a cross platform code coverage library for .NET Core, with support for line, branch and method coverage [[ Documentation SshComandLinuxTask Runs specified command on the remote host. SshCopyLinuxTask Copy projects/files to the remote host. SystemCtlLinuxTask Runs system ctl.","title":"Tasks"},{"location":"tasks/#tasks","text":"Task name Description RunProgramTask Task runs specified external program CompileSolutionTask Task compiles specified solution. PackageTask Task Packages specified directories and files into specified directory or zip file.. FetchBuildVersionFromFileTask Task fetches build version from file. GitVersionTask GitVersion is a tool to help you achieve Semantic Versioning on your project. [[ Documentation FetchVersionFromExternalSourceTask Task fetches build version from external source(Appveyor, travis, jenkins...). GenerateCommonAssemlbyInfoTask Task generates common assembly info for solution NUnitTask Task runs nunit tests with nunit.exe runner XunitTask Task runs xunit tests with xunit.exe runner NUnitWithDotCoverTaskTask runs nunit tests in combination with dotCover test coverage analysis PublishNugetPackageTask Task publishes nuget package to specified nuget server NugetCmdLineTask Manipulate nugets with nuget.exe UpdateXmlFileTask Updates an XML file using the specified update commands. UpdateJsonFileTask Task updates an JSON file using the specified update commands. CleanoutputTask Task clean all projects outputs in solution. ControlServiceTask Control windows service with sc.exe command. CreateWindowsServiceTask Creates windows service with sc.exe command. ExecutePowerShellScriptTask Executes specified power shell script. SqlCmdTask Execute SQL script files with sqlcmd.exe CreateAppPoolTask Task creates new application pool in iis. ControlAppPoolTask Task can start/stop application pool. DeleteAppPoolTask Task deletes specified application pool. CreateWebApplicationTask Task creates new web application for specified web site in iis. CreateWebSiteTask Task creates new web site in iis. AddWebSiteBindingTask Task compiles specified solution. GetLocalIisVersionTask Task gets the version on iis on local machine. ReplaceTokenTask Task Replaces specified tokens in file. ReplaceTextTask Task Replaces specified texts in file. CopyDirectoryStructureTask Task copies files from one directory to another with specified filters. CopyFileTask Task copies file from from one directory to another. CopyDirectoryStructureTask Copies a directory tree from the source to the destination.. CreateDirectoryTask Task creates directory at specified location. DeleteDirectoryTask Task deletes specified directory. DeleteFilesTask Task delete files from specified directory matching specified pattern. UnzipFileTask Task unzips specified zip file to specified location. ZipFileTask Task zips specified files. OpenCoverTask Task runs open cover tool. OpenCoverToCoberturaTask Task runs open cover to cobertuta tool. CoverageReportTask Task runs the coverage report generator tool. LoadSolutionTask Task load's solution information to the flubu session. T4TemplateTask Generate T4 template with TextTransform.exe utility.. GitTasks Git Clone, Add, Commit, Pull, Push, Tag, RemoveFiles tasks. DockerTasks Build, Run, Stop Remove Container, Remove Image and all other tasks for coresponding docker cli commands. All tasks are genereated from offical docker documentation. FlubuWebApiTasks Various flubu web api client tasks.","title":"Tasks"},{"location":"tasks/#net-core-tasks","text":"Task name Description ExecuteDotnetTask Executes specified dotnet command. DotnetRestoreTask Restores the dependencies and tools for a given application / project.. DotnetPublishTask compiles the application, reads through its dependencies specified in the project file and publishes the resulting set of files to a directory. DotnetBuildTask Builds a project and all of its dependencies. DotnetPackTask command builds the project and creates NuGet packages. The result of this command is a NuGet package. DotnetNugetPushTask Pushes the nuget package to the nuget server. DotnetTestTask Runs tests using a test runner specified in the project.json / csproj. DotnetCleanTask Cleans the output of a project. DotnetToolTask All dotnet tool commands. DotnetEfTasks Various entity framework tasks. UpdateNetCoreVersionTask Updates the version in csproj / project.json file CoverletTask Coverlet is a cross platform code coverage library for .NET Core, with support for line, branch and method coverage [[ Documentation SshComandLinuxTask Runs specified command on the remote host. SshCopyLinuxTask Copy projects/files to the remote host. SystemCtlLinuxTask Runs system ctl.","title":".net core Tasks"},{"location":"write-plugins/","text":"You can write your own tasks for flubu and extend flubu fluent interface with them. When fluent interface will be extended with your custom task you could simply add it to the target or execute it with Do task with the following example code: public class BuildScript : DefaultBuildScript { protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"FlubuPlugin.Example\" ) . SetAsDefault () . Do ( DoPluginExample ); context . CreateTarget ( \"FlubuPlugin.Example2\" ) . AddTask ( x => x . ExampleFlubuPluginTask ()); } private void DoPluginExample ( ITaskContext context ) { context . Tasks (). ExampleFlubuPluginTask () . Message ( \"some example message from plugin\" ). Execute ( context ); } } How to create your own task plugin \u00b6 Create new project in vs FlubuCore.{PluginName} Add FlubuCore nuget package to project. Add task and implement it. Following code shows implementation of example flubu plugin task. public class ExampleFlubuPluginTask : TaskBase < int , ExampleFlubuPluginTask > { private string _message ; protected override string Description { get ; set ; } public ExampleFlubuPluginTask Message ( string message ) { _message = message ; return this ; } protected override int DoExecute ( ITaskContextInternal context ) { //// write task logic here. context . LogInfo (! string . IsNullOrEmpty ( _message ) ? _message : \"Just some dummy code\" ); return 0 ; } } Then you need to write an extension method to add the task to flubu fluent interface. Extension method for our example task: using FlubuCore.PluginExample ; namespace FlubuCore.Context.FluentInterface.Interfaces { public static class TaskFluentInterfaceExtension { public static ExampleFlubuPluginTask ExampleFlubuPluginTask ( this ITaskFluentInterface flubu ) { return new ExampleFlubuPluginTask (); } } } It is recommended that you add task to ICoreTaskFluentInterface or ITaskFluentInterface We would be very glad if you add your plugin to the nuget repository. It would be great if the plugin name would start with FlubuCore so others can find it. you can see whole example plugin code here","title":"How to write and use plugins"},{"location":"write-plugins/#how-to-create-your-own-task-plugin","text":"Create new project in vs FlubuCore.{PluginName} Add FlubuCore nuget package to project. Add task and implement it. Following code shows implementation of example flubu plugin task. public class ExampleFlubuPluginTask : TaskBase < int , ExampleFlubuPluginTask > { private string _message ; protected override string Description { get ; set ; } public ExampleFlubuPluginTask Message ( string message ) { _message = message ; return this ; } protected override int DoExecute ( ITaskContextInternal context ) { //// write task logic here. context . LogInfo (! string . IsNullOrEmpty ( _message ) ? _message : \"Just some dummy code\" ); return 0 ; } } Then you need to write an extension method to add the task to flubu fluent interface. Extension method for our example task: using FlubuCore.PluginExample ; namespace FlubuCore.Context.FluentInterface.Interfaces { public static class TaskFluentInterfaceExtension { public static ExampleFlubuPluginTask ExampleFlubuPluginTask ( this ITaskFluentInterface flubu ) { return new ExampleFlubuPluginTask (); } } } It is recommended that you add task to ICoreTaskFluentInterface or ITaskFluentInterface We would be very glad if you add your plugin to the nuget repository. It would be great if the plugin name would start with FlubuCore so others can find it. you can see whole example plugin code here","title":"How to create your own task plugin"},{"location":"AwesomePlugins/awesome-plugins/","text":"FlubuCore.CakePlugin - Cake have quite alot of useful addins. This plugin allows you to use any Cake addins in FlubuCore. FlubuCore.Azure - Plugin adds over 2000 generated tasks for Azure CLI commands. Tasks are generated from offical documentation. FlubuCore.Diff - Plugin adds Diff task to FlubuCore task fluent interface. Diff task compares 2 specified files and generates html report with differences. FlubuCore.Gitter - Plugin for sending gitter messages in specified room. FlubuCore.Kubernetes - Will not be implemented. Use Kurernetes client with FlubuCore instead. FlubuCore.Npm - Plugin adds tasks for numerous npm CLI commands. FlubuCore.Octopus - Plugin adds tasks for numerous octopus CLI commands. FlubuCore.Slack - Plugin for sending message to slack channels. FlubuCore.Chocolatey - Plugin adds tasks for numerous Chocolatey CLI commands. Chocolatey is a software management solution unlike anything else you've ever experienced on Windows. It focuses on simplicity, security, and scalability. You write a software deployment in PowerShell once for any software (not just installers), then you can deploy it everywhere you have Windows with any solution that can manage systems (configuration management, endpoint management, etc) and track and manage updates of that software over time. [FlubuCore.Teams] ( https://github.com/flubu-core/FlubuCore.TeamsPlugin ) - Plugin adds task for sending messages to Microsoft teams via incoming web hook.","title":"Plugins"},{"location":"Blogs/blogs/","text":"Huanlin's Getting started with FlubuCore","title":"Blogs"},{"location":"FAQ/faq/","text":"Why FlubuCore? Native access to the whole .NET ecosystem and full IDE support inside of your scripts. With flubu you can execute your script anywhere it doesn't need to be in a project. This is important for deployment scripts or if you want to write some other scripts that are not releated to build scirpts or deploy scripts Flubu allows multiple tasks in target. Easy access to tasks through fluent interface Context.AddTask() or Context.Tasks() Each Flubu built in task derives from base class task meaning each built in task have retry, OnError, Finally, When, Interactive and some others mechanisms Pass command line arguments, settings from json configuration file or environment variables to your Properties in script. Allows you to reuse set of tasks. See Sample flubu supports parallel / async execution of target's, target dependencies and tasks to each task that execute external program or command you can add custom arguments with .WithArguments() method or even decide not to use fluent interface (good example: https://github.com/azabluda/InfoCarrier.Core/blob/develop/BuildScript/BuildScript.cs ) Alternative target definitions with attributes Flubu web api allows you to execute scripts remotely (usefull for deployments but not limited to) Override existing options or add additional options to tasks through console. https://flubucore.dotnetcore.xyz/override-add-options/ Flubu have really nice interactive mode https://flubucore.dotnetcore.xyz/build-script-runner-interactive/ Flubu Supports .net 461+ and .net core 1.0 Should I call Execute method when executing flubu built in task? if you are adding task to target through AddTask method Flubu calls Execute method when executing that target so in this scenario you should not call Execute on the task context . CreateTarget ( \"Build\" ) . AddCoreTask ( x => x . build ()); In the sample above BuildTask is added to the target. When target is executed Flubu executes all tasks that were added to target by calling task Execute method. in this case it executes BuildTask context . CreateTarget ( \"LoginEcr\" ) . Do ( c => { c . Tasks () . RunProgram ( \"aws\" ) . WithArguments ( \"ecr\" , \"get-login\" , \"--region\" , \"eu-central-1\" , \"--no-include-email\" )) . Execute ( context ); } In this sample Do actually adds DoTask to the target. When target is executed Flubu executes DoTask . DoTask in above example invokes Anonymous method which was assigned to the Action delegate (first parameter in Do Method). Flubu can not execute by itself tasks in the anonymous method you have to call Execute() method manually. Can I get output of the program, process or command that I am executing with Flubu? Yes you can with CaptureOutput method in RunProgramTask public class MyScript : DefaultBuildScript { protected override void ConfigureTargets ( ITaskContext context ) { context . CreateTarget ( \"Example\" ) . Do ( RunProgramOrCommandExample ); } public void RunProgramOrCommandExample ( ITaskContext context ) { var task = context . Tasks (). RunProgramTask ( \"EnterPathToProgramOrCommand\" ) . WithArguments ( \"Add arguments if needed\" ) . CaptureOutput (); task . Execute ( context ); var output = task . GetOutput (); } } Can I access Properties or flubu BuildProperties in ConfigureTargets method? In most cases you can as long as they are not set in a Do method or in a task. public BuildVersion BuildVersion { get ; set ; } = null ; public int SimpleSample { get ; set ; } = 0 ; protected override void ConfigureTargets ( ITaskContext context ) { var fetchBuildVersion context . CreateTarget ( \"fetch.buildVersion\" ). Do ( FetchBuildVersion ); context . CreateTarget ( \"Build\" ) . DependsOn ( fetchBuildVersion ) . AddCoreTask ( x => x . Build () . Version ( BuildVersion . BuildVersionWithQuality ())); /// BuildVersion is null here. context . LogInfo ( $ \"sample value: '{SimpleSample}'\" ); /// logs 0 and not 5. Explained below why is it so. } private void FetchBuildVersion ( ITaskContext context ) { BuildVersion = context . Tasks (). FetchBuildVersionFromFileTask () . ProjectVersionFileName ( \"project_version.txt\" ) . Execute ( context ); SimpleSample = 5 ; } In sample above you could think that when property SimpleSample is accessed in ConfigureTargets it would not be 0 but it is becuase ConfigureTargets method is always executed before all targets that are executed with flubu ConfigureTargets is also executed before all target dependecnies and tasks that were added to target","title":"FlubuCore"},{"location":"WebApi/getting-started/","text":"About \u00b6 With FlubuCore web api you can execute FlubuCore scripts remotely. Mainly it is meant to automate deployment of .net or .net core applications from your build server to different environments but it can be used for any other FlubuCore script execution. Web Api supports: Executing flubu scripts on the server where web api is deployed. Uploading (deploy or any other) packages to the server where web api is deployed. Deleting packages from server where web api is deployed. Sending reports back to client. Uploading FlubuCore scripts to the server where web api is deployed. Automatic updates Manual target execution through FlubuCore web app(deployed together with web api) In this getting started tutorial we will: Deploy FlubuCore web api to the server. Write .net deployment script that will deploy mvc example application on the sever. You should go through this tutorial even if you want to use FlubuCore.WebApi for .net core application deployment. There are few small differences between using FlubuCore.WebApi for deploying .net core applications and .net applications. All differences are written in this tutorial. Write build script that will upload deployment package of the example application to the server and execute deployment script that we wrote. Run deployment script through build script remotely. Requirements \u00b6 .net 462+ runtime or .net core runtime installed on the server. Depending on which build of FlubuCore.WebApi you plan to use. Web api deployment \u00b6 Get appropriate web api deploy package from https://github.com/flubu-core/flubu.core/releases . Copy web api deployment package to the server where you want to execute flubu script. Unzip the package. Set web api deployment configuration settings in the unzipped DeploymentConfig.json file. More about specific deployment config settings can be found in the configuration file. On windows server run deploy.bat to deploy the web api On linux/mac server run: dotnet restore and after that: dotnet flubu -s=deploymentscript.cs On deployed location run dotnet FlubuCore.WebApi.dll to selfhost web api. You can of course also host it for example on iis... IIS deployment \u00b6 How to deploy asp .net core application see: https://docs.microsoft.com/en-us/aspnet/core/publishing/iis?tabs=aspnetcore2x Some actions might need administration rights like starting / stoping the application pool. If that's the case u have to change identity on the application pool where you hosted the web api. Go to Application pools -> Web api app pool -> Advanced settings -> process model -> Identity and change to user which has admin rights. Write deploy script \u00b6 Example .net deploy script can be found Here . If u want to try the example the best way is to just clone the flubu core examples directory. Deploy script for .net core application would be of course slightly different. Example deploy script for .net application will Create iis application pool if it doesnt exists Stop the application pool Unzip package from /packages directory(which will be uploaded to web api with build script) Copy unziped application to new folder where it is/will be hosted. Create web site on iis for example web application Start the application pool When you finish writing your deploy script manually copy it to web api deployed location /scripts folder. Web api can also upload scripts but it is disabled by default for obvious security reason. It should stay disabled in most cases. If needed modify Example DeployScript for your needs. Write build script \u00b6 Example .net build script can be found here Example .net build script will Get the authentication token Delete old packages from /packages folder on web api. Upload package to web api /packages folder Execute Deployment script in /scripts folder that we manually uploaded If needed modify Example BuildScript for your needs. Run deploy script \u00b6 If u cloned example repository just execute at the root foolder: dotnet restore buildscript.csproj and dotnet flubu deploy -s=buildscript\\buildscript.cs in cmd from DeployScriptExample folder In real case scenario you would probably deploy from your build server after sucesfull build, after merge to release branch, manually execute the job on build server... Security \u00b6 As attacker can do alot of damage if he gains access to web api next security measures should be implemented if possible: If possible Flubu web api should not be publicly accessible. Always host web api on https. Restrict access by ip(config). Restrict access by time frame(config). This security measure should be taken if you deploy your application always at same time e.g 11pm. Then time frame when api can be accessed should be set for example from 11pm to 11.15pm, Use very strong password(web api user creation). Do not disable feature \"Restrict access on failed login\"(config). Enable email notifications when GetToken/Script is executed on api(config). For detailed description of security settings see appsettings.json file on web api. Automatic update \u00b6 You can automatically update FlubuCore web api if new version is available. Just navigate to /UpdateCenter (not /api/UpdateCenter) Manual target execution remotely through FlubuCore web app \u00b6 You can manually execute target through FlubuCore web app. Just navigate to /Script","title":"Getting started"},{"location":"WebApi/getting-started/#about","text":"With FlubuCore web api you can execute FlubuCore scripts remotely. Mainly it is meant to automate deployment of .net or .net core applications from your build server to different environments but it can be used for any other FlubuCore script execution. Web Api supports: Executing flubu scripts on the server where web api is deployed. Uploading (deploy or any other) packages to the server where web api is deployed. Deleting packages from server where web api is deployed. Sending reports back to client. Uploading FlubuCore scripts to the server where web api is deployed. Automatic updates Manual target execution through FlubuCore web app(deployed together with web api) In this getting started tutorial we will: Deploy FlubuCore web api to the server. Write .net deployment script that will deploy mvc example application on the sever. You should go through this tutorial even if you want to use FlubuCore.WebApi for .net core application deployment. There are few small differences between using FlubuCore.WebApi for deploying .net core applications and .net applications. All differences are written in this tutorial. Write build script that will upload deployment package of the example application to the server and execute deployment script that we wrote. Run deployment script through build script remotely.","title":"About"},{"location":"WebApi/getting-started/#requirements","text":".net 462+ runtime or .net core runtime installed on the server. Depending on which build of FlubuCore.WebApi you plan to use.","title":"Requirements"},{"location":"WebApi/getting-started/#web-api-deployment","text":"Get appropriate web api deploy package from https://github.com/flubu-core/flubu.core/releases . Copy web api deployment package to the server where you want to execute flubu script. Unzip the package. Set web api deployment configuration settings in the unzipped DeploymentConfig.json file. More about specific deployment config settings can be found in the configuration file. On windows server run deploy.bat to deploy the web api On linux/mac server run: dotnet restore and after that: dotnet flubu -s=deploymentscript.cs On deployed location run dotnet FlubuCore.WebApi.dll to selfhost web api. You can of course also host it for example on iis...","title":"Web api deployment"},{"location":"WebApi/getting-started/#iis-deployment","text":"How to deploy asp .net core application see: https://docs.microsoft.com/en-us/aspnet/core/publishing/iis?tabs=aspnetcore2x Some actions might need administration rights like starting / stoping the application pool. If that's the case u have to change identity on the application pool where you hosted the web api. Go to Application pools -> Web api app pool -> Advanced settings -> process model -> Identity and change to user which has admin rights.","title":"IIS deployment"},{"location":"WebApi/getting-started/#write-deploy-script","text":"Example .net deploy script can be found Here . If u want to try the example the best way is to just clone the flubu core examples directory. Deploy script for .net core application would be of course slightly different. Example deploy script for .net application will Create iis application pool if it doesnt exists Stop the application pool Unzip package from /packages directory(which will be uploaded to web api with build script) Copy unziped application to new folder where it is/will be hosted. Create web site on iis for example web application Start the application pool When you finish writing your deploy script manually copy it to web api deployed location /scripts folder. Web api can also upload scripts but it is disabled by default for obvious security reason. It should stay disabled in most cases. If needed modify Example DeployScript for your needs.","title":"Write deploy script"},{"location":"WebApi/getting-started/#write-build-script","text":"Example .net build script can be found here Example .net build script will Get the authentication token Delete old packages from /packages folder on web api. Upload package to web api /packages folder Execute Deployment script in /scripts folder that we manually uploaded If needed modify Example BuildScript for your needs.","title":"Write build script"},{"location":"WebApi/getting-started/#run-deploy-script","text":"If u cloned example repository just execute at the root foolder: dotnet restore buildscript.csproj and dotnet flubu deploy -s=buildscript\\buildscript.cs in cmd from DeployScriptExample folder In real case scenario you would probably deploy from your build server after sucesfull build, after merge to release branch, manually execute the job on build server...","title":"Run deploy script"},{"location":"WebApi/getting-started/#security","text":"As attacker can do alot of damage if he gains access to web api next security measures should be implemented if possible: If possible Flubu web api should not be publicly accessible. Always host web api on https. Restrict access by ip(config). Restrict access by time frame(config). This security measure should be taken if you deploy your application always at same time e.g 11pm. Then time frame when api can be accessed should be set for example from 11pm to 11.15pm, Use very strong password(web api user creation). Do not disable feature \"Restrict access on failed login\"(config). Enable email notifications when GetToken/Script is executed on api(config). For detailed description of security settings see appsettings.json file on web api.","title":"Security"},{"location":"WebApi/getting-started/#automatic-update","text":"You can automatically update FlubuCore web api if new version is available. Just navigate to /UpdateCenter (not /api/UpdateCenter)","title":"Automatic update"},{"location":"WebApi/getting-started/#manual-target-execution-remotely-through-flubucore-web-app","text":"You can manually execute target through FlubuCore web app. Just navigate to /Script","title":"Manual target execution remotely through FlubuCore web app"}]}